```commandline
/etc: файлы конфигурации для большинства приложений и некоторых частей ОС
/home: как правило, используется для хранения домашних директорий пользователей, например /home/ваше_имя_пользователя. Аналогично C:\Users в Windows.
/root: домашняя директория пользователя root (это единственный пользователь-администратор во всех UNIX-подобных ОС).

/bin: большинство исполняемых файлов (например, программ) хранится здесь. В современных версиях Linux директория /bin часто служит так называемой символьной ссылкой на директорию /usr/bin, а не "настоящей" директорией - если кратко, любая операция, затрагивающая /bin/something будет фактически выполняться на /usr/bin/что-нибудь. О подробностях работы с символьными ссылками мы поговорим позже.

/sbin: похож на /bin, но хранит специальные исполняемые файлы, служащие для конфигурации системы и обычно запускаемые только пользователем root.
/tmp: временные файлы ОС и приложений (аналог C:\Temp в ОС Windows).

/var: содержит различные файлы с кэшем системы, файлы журналов и файлы баз данных (если сервер БД установлен). Директория /var/log хранит файлы журналов системы и большинства приложений.

/usr: в настоящее время это главное место для приложений (исключая настройки, хранящиеся в /etc). Например: /usr/bin содержит исполняемые файлы, /usr/lib — разделяемые библиотеки и т. д.
```

### Формат текстовых файлов UNIX
*В UNIX-подобных ОС, включая Linux, текстовые файлы имеют свой собственный формат, отличный от Windows.*

+ Их строки заканчиваются символом '\n' (он не отображается на терминале, но все же существует), который также называется LF, его ASCII-код - 10 (0xA в шестнадцатеричной системе).
+ Символы '\r\n' играют ту же роль в Windows, символ '\r' также называется CR, его ASCII код - 13 (0xD в шестнадцатеричной системе).

Можно использовать очень простую команду "file", которая определяет формат указанных файлов
```commandline
file passwd*
passwd: 	ASCII text
passwd.win: ASCII text, with CRLF line terminators
```
*"ASCII text" показан для исходных текстовых файлов UNIX, а "ASCII text, with CRLF line terminators" для текстовых файлов Windows.*

*Чтобы преобразовать их в командной строке Linux, вы можете использовать инструменты "dos2unix" и "unix2dos" соответственно (если они, конечно, установлены).*

## Методы перенаправления вывода

### *stdout*
Представьте, что у нас есть программа, которая быстро генерирует множество выходных строк в stdout.
мы можем использовать одну из следующих техник:
```commandline
some_program > output_file_rewrite
some_program >> output_file_append

'>' перезапишет файл
'>>' добавит stdout программы к содержимому существующего файла

Например:
egrep root /etc/passwd > file.txt
```
*Оба метода создают выходной файл, если он не существовал ранее.*  
В обоих случаях, показанных выше, stdout программы будет записан в указанный файл, а не в терминал.

### *stderr*
Если вы хотите сохранить сообщения об ошибках отдельно от "полезного" вывода, можно запустить программу следующим образом:
```commandline
egrep root /no/such/file 2> file.txt
egrep root /no/such/file 2>> file.txt
```
*Важные замечания о перенаправлении stderr:*
+ Не забудьте указать '2', если вы работаете с stderr
+ Пробелы между '2' и '>' (или '>>') не допускаются, поэтому:
  + '2> файл', '2>> файл' разрешены
  + 2 > файл", "2 >> файл" являются неправильными

*'2' - это внутренний номер (или ID) потока stderr. Между тем, stdout имеет ID 1, но вам не нужно набирать '1> output_file', так как перенаправление stdout используется по умолчанию.*

### *Объединение stdout и stderr*
```commandline
some_program > output_file 2>&1

Это работает следующим образом:
-Stderr перенаправляется в stdout (порядок перенаправления - "чтение" справа налево)
-Stdout записывается в "output_file"

В результате, оба потока (stdout и stderr) будут записаны в один файл.

Пример:
egrep root /etc/passwd /no/such/file > file.txt 2>&1
```

### */dev/null*
Часто, но не всегда, лучше полностью игнорировать ошибки или stdout, и показывать только один поток. Для этих целей существует специальное псевдоустройство /dev/null - вы можете записать на него что угодно, и эта информация исчезнет, как в черной дыре.
```commandline
egrep root /no/such/file 2>/dev/null
```

Если хотите проигнорировать обычные сообщение, напишите так:
```commandline
egrep root /etc/passwd /no/such/file > /dev/null
```

## *Пайпы (pipes)*
*Пайпы (Pipes) предназначены для перенаправления stdout одной программы в stdin другой.*

![Пайпы pipes](images/pipes.png "Работа pipes")

### *stdin*
Используется для получения входных данных - как поток, а не как входной файл.

*Примеры*
```commandline
egrep user /etc/group
"egrep" просто читает входной файл. Здесь нет ничего, связанного с входными потоками
```

```commandline
cat /etc/group | egrep user
"cat" просто печатает входной файл в stdout. Затем, с помощью пайпа через '|' между "cat" и "egrep", это содержимое передается в виде потока на stdin egrep. "egrep" читает свой stdin и ищет заданный шаблон.
```

```commandline
egrep user < /etc/group
"egrep" заполняет свой stdin из файла, указанного после '<', и ищет шаблон в потоке входных данных.
```

#### *Примечание:*
не пытайтесь заполнить stdin команды через pipe и '<' одновременно. В этом случае на вход будет принят только файл, а stdout предыдущей команды будет проигнорирован. Итак:
```commandline
cmd1 | cmd2 - верно
cmd2 < /some/file - верно
cmd1 | cmd2 < /some/file - неверно, поскольку cmd2 получит на вход тольк содержимое /some/file, при этом результат cmd1 будет проигнорирован.
```

*Примеры*
```commandline
cat /etc/passwd /etc/group ~/.bash_history | egrep user
печатает все строки, содержащие "user", из нескольких файлов, объединенных программой cat

cat /etc/passwd /etc/group ~/.bash_history | egrep user | less
делает то же самое, но показывает это в постраничном представлении, обеспечиваемом"less"

egrep "cat" ~/.bash_history | sort | uniq
ищет строки, содержащие "cat" в истории команд, затем печатает только уникальные строки без дубликатов

egrep "cat" ~/.bash_history | sort | uniq | wc -l
показывает количество строк, найденных выше
```
*Важные замечания*
+ Пайпы похожи на '>' и '>>', поэтому ваш stdout НЕ будет отображаться в терминале.
+ Stdout может быть записан в файл ИЛИ передан в stdin следующей команды, но НЕ одновременно.  Поэтому НЕ ожидайте, что что-либо будет передано в "next_command" в примере ниже.
````commandline
some_command > result | next_command

поскольку stdout команды some_command уже был записан в файл "result", для заполнения stdin следующей команды (т.к. next_command) ничего не остается.
````

+ Пайпы могут работать только с stdout, поэтому
  + Если что-либо было выведено на stderr, и stderr не был обработан отдельно, вы также увидите сообщения stderr среди обработанных строк. Схематично это показано на рисунке ниже:
![Пайпы pipes](images/pipes2.png "Работа pipes")
*В этом примере 1-й stderr не обрабатывается, поэтому он выводится на терминал так же, как и результат "head".*
+ Если вы хотите работать через пайпы с stderr, можно использовать конструкцию ниже. Она объединяет stdout и stderr для "next_command":
````commandline
some_command 2>&1 | next_command
````
![Пайпы pipes](images/pipes3.png "Работа pipes")
*Пайплайн из предыдущей схемы теперь работает по-другому, так как 1-й stderr обрабатывается и объединяется с stdout.*

*Более сложная конструкция:*
````commandline
some_command 2>&1 >/dev/null | next_command

будет игнорировать stdout команды some_command, перенаправлять ее stderr в stdout и предоставлять его в качестве входных данных для "next_command". То есть, если вы хотите работать только с stderr и полностью игнорировать stdout, вы можете ее использовать.
````

Чтобы понять эти принципы, выполните команды:
````commandline
cat /etc/passwd /etc/group | egrep "no such pattern"

Ничего не выводится, поскольку:
a) stdout cat был полностью отправлен в stdin egrep 
b) egrep не нашел ни одной строки с "no such pattern".
````

````commandline
cat /etc/passwd /etc/group > /tmp/result.file | egrep "user"

stdout cat был полностью записан в /tmp/result.file, поэтому egrep принимал пустые входные данные. Если же вы запустите
cat /etc/passwd /etc/group | egrep "user"
некоторые строки с высокой долей вероятности будут напечатаны.
````

*Теперь stderr и пайпы:*
````commandline
cat /etc/passwd /etc/group /no/such/file1 /no/such/file2 | egrep root | head -n 2

Вы, вероятно, ожидаете только 2 строки в выводе (из-за "head -n 2"), но на самом деле увидите четыре: две "паразитные" строки с ошибками "No such file or directory" (потому что они были выведены на stderr, сам stderr не был ни перенаправлен, ни проигнорирован) и две "нормальные" строки, в которых найдется шаблон.
````

````commandline
cat /etc/passwd /etc/group /no/such/file1 /no/such/file2 2>&1 | egrep "No such file or directory" | head -n 2

Эта конструкция печатает только 2 первые строки, содержащие подстроку "No such file or directory", найденные в объединенных stdout и stderr cat, другие строки не печатаются, и это ожидаемое поведение (поскольку поток ошибок был объединен со стандартным выводом).
````
## Учетные записи ОС
````text
В UNIX-подобных операционных системах существует несколько типов пользователей ОС (т.е. учетных записей):

Стандартные учетные записи: создаются для обычных пользователей
Административная учетная запись: ее имя - root, и она является единственным администратором ОС (у вас не может быть двух root). Учетная запись root используется для прямого входа в систему очень редко; вместо этого администраторы временно повышают свои привилегии до root для обслуживания системы и других важных операций.
Служебные учетные записи: создаются для служб и других специальных целей; не должны использоваться пользователями. Например, для запуска бэкэнд-приложения (или приложения сервера базы данных) должна использоваться отдельная учетная запись.  Это минимизирует возможные последствия в случае сбоя или взлома приложения.
````
### *В чем разница:*
````text


Стандартные учетные записи: могут входить в систему, выполнять команды и читать некоторые файлы или директории. Они не могут изменять любую часть ОС и "общесистемных" приложений. По умолчанию они могут изменять данные только в своих домашних директориях и /tmp.
Административная (root) учетная запись: может входить в систему и делать все с ОС и пользователями без каких-либо ограничений (в отличие от Windows, где учетная запись администратора не настолько мощная, как учетная запись "Локальная система").
Служебные учетные записи: не могут входить в систему. ОС, службы и приложения (запускаемые root) используют их для специальных целей, например, для запуска определенных программ, служб и т.д.
````

### Основные настройки учетной записи: /etc/passwd
/etc/passwd - это основной конфигурационный файл для учетных записей пользователей, который используется, когда:
+ Пользователь входит в систему по SSH, FTP и другим средствам/протоколам.
+ ОС или любая программа требует, чтобы имя пользователя было сопоставлено с числовым UID (см. ниже) или наоборот.
+ Что вы можете видеть относительно своей учетной записи: (помните, "${USER}" означает ваше имя пользователя)

````commandline
[feodor@c7-sandbox ~]$ egrep "${USER}" /etc/passwd
feodor:x:1000:100:User Description Here:/home/feodor:/bin/bash
````
Рассмотрим содержимое и формат этого файла. В качестве разделителя полей используется ':', таким образом:
+ feodor - имя пользователя, должно быть уникальным
+ x - поле не используется, поэтому мы имеем здесь 'x' как заглушку
+ 1000 - идентификатор пользователя, называемый "UID", должен быть уникальным. Пользователи в основном имеют UID >= 1000. Пользователь root всегда имеет UID 0. Учетные записи служб имеют UID от 1 до (в основном) 999. Никто, кроме root, не должен иметь UID 0.
+ 100 - идентификатор основной группы. Каждый пользователь должен быть членом хотя бы одной группы (не существует пользователей "без групп"). Если пользователей нужно включить в большее количество групп, это настраивается в /etc/group (см. следующий раздел).
+ User Description Here - это поле может быть пустым или содержать что угодно, кроме ':'. Оно не играет никакой роли в ОС и механизмах входа в систему.
+ /home/feodor - домашний каталог пользователя; вы автоматически помещаетесь сюда после успешного входа в систему
+ /bin/bash - программа, выполняемая при успешном входе в систему. Сервисные учетные записи не предназначены для входа в систему и работы в командной строке, поэтому у них здесь указаны специальные "псевдо" программы, такие как /bin/false или /sbin/nologin

### *Заметки по безопасности/стабильности:*

+ Только root может изменять /etc/passwd - иначе хакеры могут повысить привилегии, создав "фальшивого рута" с UID 0.
+ Любой пользователь или приложение должны иметь доступ на чтение к этому файлу - иначе ОС становится нестабильной.
+ Хеши паролей хранятся в файле /etc/shadow, доступ к которому имеет только root. Несколько слов о хэшах: это набор однонаправленных криптографических функций, таких как хорошо известные MD5, SHA-512 и т.д. Если кто-то (например, вы или ОС) знает исходный пароль, он может быть легко преобразован в хэш. Но если вы знаете только хэш, получить начальный пароль будет очень сложно.
+ Эти особые разрешения /etc/shadow используются для того, чтобы избежать атак методом перебора. В противном случае любой может прочитать хэши, а затем попытаться подобрать правильный пароль к определенному хэшу. Файл /etc/shadow также содержит все настройки паролей учетных записей ОС, например, когда пароль должен быть изменен и т.д.

## Группы ОС
+ Группы включают несколько (0 или более) пользователей для упрощения управления пользователями и разделения привилегий
+ Каждый пользователь должен быть членом как минимум одной группы - она задается в /etc/passwd, такая группа называется "основной" для конкретного пользователя
+ Каждый пользователь может быть включен в 0 или более дополнительных групп, называемых "вторичными группами" (secondary groups). Членство во вторичных группах настраивается в файле /etc/group.
+ Нет никакой разницы (в плане привилегий) между членством в первичной и вторичной группах, например: если ваш пользователь входит в группу "qa" и группу "users", вы можете читать файлы, доступные как группам "qa", так и "users".
+ Группы полезны для назначения разрешений на доступ к файлам и других привилегий или ограничений, например:
  + кто может читать/писать/исполнять файл
  + кто может войти в систему через SSH
  + кто и как может использовать инструменты "sudo" или "su"
  + кто может читать журналы общесистемных служб с помощью инструмента "journalctl"
  + сколько процессора/памяти/дискового пространства может быть израсходовано

#### *Заметки*
+ Имена групп чувствительны к регистру, как и почти все в мире UNIX. т.е. группы "users" и "Users" - это разные группы.
+ В отличие от Windows, в UNIX нет группы "Администраторы".
+ В большинстве систем членство в группе "root" не дает многих привилегий, в отличие от статуса пользователя "root".
+ Могут существовать специальные группы с дополнительными привилегиями, это сильно зависит от настроек вашей ОС. Например, группы "sudo" или "wheel" могут иметь (а могут и не иметь) неограниченные права на выполнение любых команд от имени root через "sudo".

### *Основные настройки групп: /etc/group*
+ ОС или какой-либо программе требуется преобразовать имя группы в числовой GID (см. ниже) или наоборот.
+ Пользователь пытается сделать что-то, что может быть ограничено или разрешено функциями управления группами (например, чтение файла)
+ [опционально, если службы входа настроены таким образом] Пользователь входит в систему (SSH, FTP, другие протоколы).

Если вы посмотрите в /etc/group и найдете свое имя пользователя, вы можете увидеть что-то вроде этого:
````commandline
[feodor@c7-sandbox ~]$ egrep "$USER" /etc/group
wheel:x:10:feodor
users:x:100:feodor,[ ... a lot of users here ... ]
feodor:x:1000:
qa:x:1001:feodor,user1,user2
````

Рассмотрим последнюю строку примера выше:
+ Название группы
+ Всегда 'x'
+ Идентификатор группы, называемый "GID", должен быть уникальным
+ Список членов группы, разделенный запятыми, может быть пустым

Показать только UID текущего пользователя и ничего больше:
````commandline
[feodor@c7-sandbox ~]$ id -u
1000
````

Показать только GID или только имена групп текущего пользователя:
````commandline
[feodor@c7-sandbox ~]$ id -G
1000 10 100 987 1001
[feodor@c7-sandbox ~]$ id -Gn
feodor wheel users docker qa
````

Еще один способ получить имена групп:
````commandline
[feodor@c7-sandbox ~]$ groups
feodor wheel users docker qa
````

## "su": Переключить пользователя
Команда su используется для запуска оболочки от имени другого пользователя (по умолчанию root) после предоставления пароля пользователя.
Чтобы вернуться к предыдущему пользователю, выполните команду "exit".

Выполнение команды (или нескольких команд) от имени root, без запуска полнофункционального сеанса оболочки root:
````commandline
[st00@c7-sandbox ~]$ su - -c "id -u; whoami"
Password:
0
root
````
Всегда лучше использовать "su -" вместо "su", так как ключ "-" загружает все окружение оболочки целевого пользователя.

## "sudo": Substitute User Do
Инструмент sudo используется для запуска команды от имени другого пользователя (по умолчанию root) после предоставления пароля. "sudo" может быть настроен на разрешение или запрет выполнения определенных команд и их аргументов.

### *"sudo" обычно может использоваться как:*
````commandline
# Чтобы проверить возможности пользователя
sudo -l

# Чтобы запустить команды
sudo [-u username] command args
````
Где:
+ -u имя пользователя: какой пользователь будет выполнять эту команду (по умолчанию root, если не указано)
+ -l (строчная буква "L"): чтобы увидеть, какие команды вы можете выполнять
command, args - что выполнить с привилегиями другого пользователя

![Sudo](images/sudo.jpg "Работа с Sudo")

## sudo VS su: Основные различия
|                                     | su                                                                                                                               | sudo                                                                                                                                                     |
|-------------------------------------|----------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| Основная функциональность           | Предоставление оболочки входа в систему с привилегиями целевого пользователя, по умолчанию root                                  | Выполнение одной команды от имени целевого пользователя, по умолчанию root                                                                               |
| Основная идея                       | Работа в полнофункциональной оболочке как root или любой другой пользователь ОС                                                  | Делегирование некоторых административных полномочий обычным пользователям                                                                                |
| Какой пароль вводить                | Пароль целевого пользователя                                                                                                     | Ваш собственный пароль                                                                                                                                   |
| Необходимые настройки               | Возможно, вас нужно будет включить в специальную группу для запуска "su" (если это установлено вашим системным администратором). | Точные команды и даже их аргументы могут быть разрешены в явном виде                                                                                     |
| Настройки безопасности по умолчанию | Любой может выполнить команду "su", требуется только пароль целевого пользователя                                                | Только члены специфической для дистрибутива группы ("wheel" в RHEL-системах, например CentOS, "sudo" в Debian, например Ubuntu) могут использовать sudo. |

## Разрешения на доступ к файлам
*Пример*
````commandline
[feodor@c7-sandbox ~]$ ls -l testfile
-rw-r--r--.   1    feodor   qa    452    May 17 19:32    testfile
````
![File_Access](images/File_Access.png "Работа с File_Access")

+ '-' для типичных файлов
+ 'd' для каталогов
+ 'l' для символических ссылок, объясненных в предыдущем уроке.
+ Другие: s, p, c, b - для специальных целей, вне рамок темы.
+ И 9 следующих символов, таких как "rw-r--r--" - это разрешения доступа к файлам UNIX

### Анатомия разрешений на доступ к файлам
Представьте, что у нас есть разрешения "rwxrwxrwx", установленные на каталог.
Это можно разделить и объяснить следующим образом:

![File_Access2](images/File_Access2.jpg "Работа с File_Access")

Что касается примера, показанного выше:
```commandline
[feodor@c7-sandbox ~]$ ls -l testfile
-rw-r--r--.   1    feodor   qa    452    May 17 19:32    testfile
```
Мы можем сказать, что ('-' означает "не разрешено"):
+ Пользователь (User): разрешения владельца файла (feodor) - 'rw'.
+ Группа (Group): разрешения группы (qa) - 'r'.
+ Другие (Other): разрешения других пользователей, т.е. не являющихся ни владельцами, ни входящих в группу владельцев, также равны 'r'.

```text
Как проверяются и применяются разрешения доступа:

Во-первых: является ли пользователь владельцем данного объекта? Если да - проверить, разрешают ли разрешения владельца объекта эту операцию.
Если пользователь не является владельцем объекта - является ли он членом группы? Если да - проверить, разрешают ли групповые разрешения объекта эту операцию.
Если пользователь не входит в группу - проверить, разрешают ли разрешения других на эту операцию.
```

## Смысл и формат записи прав доступа
| Бит                        | Значение для файлов                                                                                              | Значение для директорий                                                                                                                                                                                                                                                                                                                                                                     |
|----------------------------|------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| r - read (чтение)          | Файл может быть прочитан, например, с помощью cat, less, head, других инструментов.                              | Список содержимого каталога может быть прочитан. Если бит 'x' не установлен, могут быть прочитаны только имена объектов.                                                                                                                                                                                                                                                                    |
| w - write (запись)         | Содержимое файла может быть изменено. Но сам файл не может быть удален - см. 'w' для каталогов.                  | Любой элемент этого каталога может быть создан или удален. То есть, даже если вы не являетесь владельцем файла в этом каталоге, вы можете удалить его, установив 'w' для каталога. Это можно сделать только в том случае, если бит "x" также установлен.                                                                                                                                    |
| x - execute (выполнение)   | Файл может быть выполнен. Фактически исполняемые файлы: двоичные файлы и скрипты                                 | Самый важный бит для каталогов. Вы можете войти в этот каталог (например, с помощью "cd") и получить доступ (чтение, запись, выполнение) ко всему его содержимому, если это разрешено их правами доступа. Если у вас нет 'x' для каталога, вы НЕ можете:- переходить в подкаталоги - создавать/удалять объекты (файлы, каталоги) - читать информацию об объекте (разрешения, владелец, ...) |                                                                                                                                                                                                                                  |

### Восьмеричные числа
Биты доступа (r, w, x) также могут быть записаны в виде восьмеричных чисел, т.е.:
+ 'r' равно 4 (100)
+ 'w' равно 2 (010)
+ 'x' равно 1 (001)
+ '-' равно 0 (000)

все их комбинации являются суммами этих чисел, например.
+ 'r-x' равно 5 (101)
+ 'rw-' равно 6 (110)
+ 'rwx' равно 7 (111)

### Команды для изменения разрешений доступа к файлам
Существует 3 известные команды для работы с владельцами объектов, группами и разрешениями доступа:
```commandline
chown (ИЗМЕНИТЬ ВЛАДЕЛЬЦА): для установки нового владельца и/или группы для объекта
chgrp (ИЗМЕНИТЬ ГРУППУ): то же самое, но только для группы
chmod (ИЗМЕНИТЬ РЕЖИМ): установить новые разрешения доступа к файлу
```

### *chown*
```commandline
# Создаём файл, проверяем его владельца и группу
touch ~/chown.me
ls -l ~/chown.me

# Следующую команду можно выполнить только от пользователя root
chown operator:bin ~/chown.me

# Следующую команду можно выполнить только от члена группы "users"
chown :users ~/chown.me

# С опцией "-R" команда будет применена ко всей директории HOME:
chown -R :users ~
```

### *chgrp*
```commandline
# Следующие команды приведут к идентичному результату
chown :users ~/chown.me
chgrp users ~/chown.me

# chgrp поддерживает рекурсивный режим "-R"
chgrp -R users ~
```

### *chmod*
```commandline
# Создаём 2 объекта
mkdir ~/chmod.me.dir
touch ~/chmod.me.file

# Определяем права доступа
# Установим "rwxr-x--x", т.е. 751, на указанную директорию:
chmod 751 ~/chmod.me.dir

# Добавляем "r"-бит для прочих (others) и "w" для группы:
chmod g+w,o+r ~/chmod.me.dir

# Разрешаем владельцу делать что угодно с файлом
# Добавляем права на запись группе
# Отбираем права на чтение у прочих (others)
chmod u=rwx,g+w,o-r ~/chmod.me.dir

# Меняем права доступа для всего каталога
# Отнимаем все права у группы и прочих (others):
chmod -R go-rwx ~/chmod.me.dir
```

### Типичные ошибки при работе с разрешениями доступа к файлам
+ 777 к файлам или каталогам. Это широко распространено в плохо написанных интернет-руководствах, представляющих "chmod 777" как универсальный способ для решения всех проблем, связанных с правами доступа. Никогда не делайте этого, если вы точно не знаете, что делаете. Установка этого параметра без четкого понимания определенно подвергнет этот объект высокому риску быть произвольно измененным, удаленным и (для конфиденциальных данных) прочитанным любым пользователем и процессом системы и продемонстрирует вашу неспособность правильно работать с UNIX-подобными операционными системами, что часто приводит к отзыву доступа и другим личным проблемам.
+ chmod -R 777 /some/where - еще хуже, чем просто chmod 777, так как все объекты внутри этого каталога будут подвергнуты риску.
+ Непонимание прав доступа к каталогам и их значения.
+ Игнорирование прав доступа к каталогам при попытке получить доступ к вложенным файлам.

Символические ссылки всегда имеют разрешения 777, но это ничего не значит, поскольку фактические разрешения доступа такие же, как у целевого объекта:
```commandline
lrwxrwxrwx. 1 root root 7 янв 1 21:12 /bin -> /usr/bin
dr-xr-xr-x. 2 root root 36864 фев 19 13:31 /usr/bin
```

+ Ее содержимое не может быть изменено, она может быть только пересоздана.
+ Только владелец директории (для '/' это "root") может пересоздать ее.
+ Разрешения доступа к символической ссылке не влияют на разрешения доступа к целевому объекту (в соответствии с  замыслом).

## Исполняемые файлы
*PATH - это переменная оболочки (shell variable), которая содержит список каталогов для поиска исполняемых файлов. Она может быть отображена так же, как и другие переменные shell, упомянутые в предыдущих главах (например, USER и HOME), т.е. простой командой "echo":*
```commandline
localhost:~# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

"which” это команда для показа расположения исполняемого файла в каталогах PATH:
```commandline
localhost:~# which uname
/bin/uname
```

"uname" с опцией "-a", чтобы увидеть расширенную информацию об нашей системе:
```commandline
localhost:~# uname -a
Linux localhost 4.12.0-rc6-g48ec1f0-dirty #21 Fri Aug 4 21:02:28 CEST 2017 i586 Linux
```
*Но на самом деле, когда пользователь хочет, чтобы командная оболочка выполнила команду "uname", вызывается соответствующий исполняемый файл (/bin/uname в данном случае). Поэтому предыдущий пункт можно выполнить и указав полный путь, как показано ниже.*
```commandline
localhost:~# /bin/uname -a
Linux localhost 4.12.0-rc6-g48ec1f0-dirty #21 Fri Aug 4 21:02:28 CEST 2017 i586 Linux
```

### Пример
*создадим новый исполняемый файл (на самом деле, простой shell-скрипт) в текущей рабочей директории. Этот файл будет содержать только одну строку, "uname -a".*
```commandline
localhost:~# pwd
/root
localhost:~# echo "uname -a" > executable
localhost:~# chmod 755 executable
localhost:~# ls -lF executable
-rwxr-xr-x 1 root root 9 Jan 20 20:29 executable*
```

*когда командной оболочке предоставляется исполняемый файл без полного пути к нему (например, "uname" вместо "/bin/uname"), командная оболочка пытается найти его в директориях PATH. Если ничего не найдено (так как этот файл находится в директории /root, а директория "/root" не указана в PATH), выдается соответствующая ошибка:*
```commandline
localhost:~# executable
sh: executable: not found
```

*Когда в терминале UNIX выполняется продолжительная команда, можно:*
+ Она изначально может быть запущена как фоновая задача с помощью оператора "&".
+ Можно приостановить ее нажатием Ctrl+Z, а затем для продолжения выполнения использовать встроенные модули "fg" или "bg".
+ Если команда запущена, но больше не нужна, ее можно остановить, нажав Ctrl+C.

### Запуск и остановка команд
Выполните команду, затем нажмите Ctrl+Z, и оболочка покажет, что эта команда была приостановлена (не завершена):
```commandline
localhost:~# sleep 1000
^Z
[1]+ Stopped sleep 1000
```

Выполнив команду "jobs" (это встроенная команда оболочки), вы увидите все задания оболочки с их идентификаторами и статусами
```commandline
localhost:~# jobs
[1]+ Stopped sleep 1000
```

Теперь выполнение команды "sleep" остановлено, но его можно возобновить, вызвав команду "bg" с %ID задачи, которую нужно возобновить. Указанная задача будет отправлена на фоновое выполнение.
```commandline
localhost:~# bg %1
[1]+ sleep 1000 &
```

Теперь "jobs" отображает команду "sleep" как запущенную:
```commandline
localhost:~# jobs
[1]+ Running sleep 1000 &
```

Чтобы избежать этих манипуляций, иногда проще выполнить длительную команду в фоновом режиме с самого начала через оператор "&" в конце строки.  Оболочка отображает внутренний идентификатор этой задачи в квадратных скобках, здесь это [2].
```commandline
localhost:~# sleep 2000 &
[2] 157
```

Теперь есть 2 задачи текущих сеансов оболочки, обе выполняются:
```commandline
localhost:~# jobs
[1]- Running sleep 1000 &
[2]+ Running sleep 2000 &
```

Команды также могут быть переведены на передний план с помощью встроенной оболочки "fg". Здесь на передний план была помещена первая команда "sleep". Затем она была завершена нажатием Ctrl+C:
```commandline
localhost:~# fg %1
sleep 1000
^C
```

После завершения первой задачи остается только вторая:
```commandline
localhost:~# jobs
[2]+ Running sleep 2000 &
```

Любая задача оболочки может быть завершена командой "kill" (может существовать как исполняемый файл или встроенный в оболочку) с указанием ее %ID. После этого никаких задач не останется.
```commandline
localhost:~# kill %2
[2]+ Terminated sleep 2000
localhost:~# jobs
localhost:~#
```

### "Алиас" (псевдоним)
Это определенное пользователем имя существующей команды (и, возможно, ее опций). Если "b" является псевдонимом для "a --option1 --option2", то когда оболочке входа в систему предлагается выполнить "b --some-options arguments", на самом деле вместо этого будет выполнено "a --option1 --option2 --some-options arguments". Часто система Linux настроена так, что некоторые псевдонимы для всех пользователей доступны сразу же, например, "ll" (ls -l), "la" (ls -a).

Встроенная команда - это имя команды, которая поддерживается оболочкой входа в систему (/bin/bash является оболочкой входа в систему в большинстве случаев), но не существует в виде отдельного исполняемого файла. Примеры: cd, pwd, test - эти команды часто представлены в виде "настоящих" исполняемых файлов, но если это не так, оболочка входа в систему может выполнить соответствующие действия и сама.

По умолчанию какие-либо псевдонимы могут отсутствовать.
Пользователи могут определять свои собственные псевдонимы и переменные оболочки в файлах ~/.bashrc и(или) ~/.bash_profile, поэтому хорошей идеей будет добавить туда новую строку с определением псевдонима.
```commandline
localhost:~# echo "alias lf='ls -lF'" >> ~/.bashrc
```

Давайте проверим, задействована ли новая конфигурация. Мы видим новый псевдоним, значит, всё работает отлично. Напоминаем, что псевдоним не является исполняемым файлом и его путь нельзя выяснить с помощью команды.
```commandline
localhost:~# alias
alias lf='ls -lF'
localhost:~# which lf
localhost:~#
```

Если псевдоним более не нужен, можно "приказать" оболочке "забыть" о нем с помощью встроенной команды unalias:
```commandline
localhost:~# unalias lf
localhost:~# lf /etc/passwd
bash: lf: command not found
```

## Процессы и сигналы
Процесс операционной системы (ОС) — это экземпляр исполняемой программы, выполняемый системой в настоящее время. Это означает, что если программа заканчивает свою работу или завершается пользователем, то процесс также прекращает своё существование.

*Каждый процесс имеет несколько следующих основных атрибутов:*
+ PID - идентификатор процесса. Уникален для каждого выполняющегося процесса. То есть в каждый момент времени все процессы имеют различные идентификаторы PID. При повторном запуске той же программы соответствующие создаваемые процессы будут обладать новыми PID.
+ PPID — родительский идентификатор (PID). Процессы не возникают сами по себе, они создаются другими процессами. Таким образом, PPID - это PID родительского процесса.
+ А кто запускает самый первый процесс? «Главный» системный процесс называется init или systemd и обладает PID = 1, PPID = 0. Он создаётся ядром операционной системы при её загрузке.

+ Пользователь и группа, запустившие программу.
+ Название.
+ Аргументы командной строки.
+ Управляющий терминал. Указывается для процессов, взаимодействующих с терминалом и (или) пользователями в диалоговом режиме. Например, командный интерпретатор bash, который обычно запускается при входе пользователя в систему, определённо взаимодействует с терминалом и пользователями, и поэтому у него есть управляющий терминал.

Типичный сервер на ОС Linux (и UNIX) содержит множество работающих процессов, выполняющих различные функции: обработка входящих сетевых запросов от конечных пользователей, обработка данных, запуск запланированных задач, отслеживание состояния системы, работа интерактивных командных оболочек (типа bash) для выполнения команд пользователей и т. д. Все эти функции, как правило, выполняются без вмешательства человека отдельными процессами, которые созданы для автоматической работы
Такая автоматизация возлагается на специальные процессы, называемые демонами (это страшное слово часто используется в мире UNIX).
Демоны — это особый вид процессов (введите «man 7 daemon» в командном интерпретаторе, чтобы узнать больше).

«Настоящий» процесс-демон обладает следующими свойствами:

+ PPID = 1
+ Управляющий терминал отсутствует
+ В большинстве случаев текущей рабочей директорией демона является "/".


Существует несколько часто используемых инструментов и способов получения информации обо всех или конкретных запущенных процессах:
+ ps — основной инструмент для отображения списка запущенных процессов
+ top - инструмент для отслеживания запущенных процессов в реальном времени, аналог диспетчера задач Windows и мониторинга системы macOS
+ pgrep - инструмент для поиска процессов по их названию или аргументам
+ pstree - инструмент для отображения процессов в виде дерева. Полезен для изучения работы приложений
+ В псевдо-каталоге /proc/PID содержится много подробных сведений о процессе с идентификатором PID. Очень полезен в некоторых случаях



## Как искать процессы и просматривать их списки

### *Команда ps*
ps — основной инструмент для отображения списка запущенных процессов
Отображает список процессов, работающих в текущий момент времени, а затем завершает свою работу. Самые полезные ее опции следующие:
+ -e для отображения всех процессов всех пользователей. По умолчанию показываются процессы только текущего пользователя.
+ -f для вывода расширенных сведений о каждом процессе. По умолчанию отображается только ограниченный объём информации.
+ -u username для отображения процессов, запущенных пользователем c данным именем (username).
+ -p PID - для вывода сведений об процессе с данным PID
+ -o поле1, поле2,... - для вывода определённых сведений о процессах (см. подробное руководство с помощью команды man ps).
```commandline
Пример
ps -ef
покажет запущенные процессы с расширенными сведениями

ps -fu $USER
покажет процессы текущего пользователя
```
Значение каждого столбца следующее:

+ UID: имя пользователя, запустившего процесс
+ PID: идентификатор процесса
+ PPID: идентификатор родительского процесса
+ C: не имеет значения и не показывается в выводе команды ps на эмуляторе
+ STIME: время запуска процесса. Не показывается на эмуляторе
+ TTY или TT: управляющий терминал. Знак «?» показывается для процессов, не связанных с терминалом (таких как демоны)
+ TIME: суммарное процессорное время выполнения
+ CMD: команда с аргументами. Может включать полный путь к исполняемому файлу процесса, но это не гарантировано. Если название процесса показано в квадратных скобках, значит, этот процесс является частью ядра ОС.

У команды ps есть интересная опция --forest, служащая для отображения процессов в виде дерева аналогично команде pstree. Отображаются родительские процессы и их дочерние процессы, наглядно показывая связи между ними.
```commandline
ps -e -o uid,pid,ppid,stime,tty,time,args --forest
```
![Process](images/process.png "Работа с Process")

Итак, что именно показано на этом снимке экрана и как это следует интерпретировать:

+ Первое: пользователь запускает два процесса программы sleep в фоновом режиме. Их идентификаторы PID: 26738 и 26743
+ Затем запускается команда ps с нужными аргументами.
+ Первый процесс в отображаемом этой командой списке — sshd с PID = 25382. Он отвечает за удалённый вход в систему: текущий пользователь st00 вошёл в систему посредством сессии SSH.
+ Процесс оболочки bash с PID = 25383 является дочерним для процесса sshd. В действительности это стартовая командная оболочка, запущенная процессом sshd после успешного входа в систему.
+ Ниже отображаются два процесса sleep, являющиеся дочерними для процесса bash.  Посмотрите на их идентификаторы PID, они совпадают с идентификаторами, показанными оболочкой (см. п. 1).
+ Сама программа ps запущена процессом bash, то есть является его дочерним процессом.
+ Ниже отображаются процессы "npm" и "node". Процесс "npm" с PID=28513, скорее всего, является демоном, так как его PPID=1, а TTY="?".
+ Последняя команда "echo $$" - это трюк для получения PID текущей оболочки входа в систему. "$" - это переменная оболочки для хранения значения PID, поэтому "$$" = 25383, это то же самое, что показано в п.4.

## *Команда pgrep*
Она помогает быстро найти процесс (или процессы), используя логику, аналогичную инструменту "egrep":
+ -f: для поиска в полной командной строке (т.е. как имена команд, так и аргументы). По умолчанию проверяются только имена команд
+ -a: для вывода списка всей командной строки, а не только PID.

```commandline
Пример
pgrep -fa apache2
```

### *Псевдо-директория /proc*
+ Это виртуальная файловая система, содержащая множество сведений о работающих процессах.  Её называют псевдо-файловой системой, так как в реальности на диске нет файлов, расположенных в директории /proc. Вместо этого ядро операционной системы отображает информацию в виде файлов и директорий в директории /proc.
+ Все команды, относящиеся к процессам, такие как ps, pstree, pgrep, берут информацию из директории /proc.
+ Можно получить информацию о ваших процессах напрямую из директории /proc
+ Чтобы узнать точный путь к исполняемому файлу и (или) текущую рабочую директорию, можно напрямую обратиться к директории /proc.

### *Отслеживание процессов и команда top*
Команда top выводит в реальном времени сведения о работающих процессах и текущую нагрузку на систему (центральный процессор, память, задачи), а также позволяет отправлять процессам сигналы и завершать их работу. 
В отличие от ps, команда top работает, пока пользователь не остановит её, и показывает объём используемых системных ресурсов в реальном времени.
Она обновляет экран каждые несколько секунд.
Этот инструмент очень полезен для выполнения следующих действий:

+ Поиск процессов, которые больше других потребляют ресурсы процессора и памяти.
+ Определение текущей загрузки системы.

*Основные горячие клавиши для программы top:*
+ q - выход из программы (quit)
+ 1 (один) — отображение или скрытие сведений о загрузке процессора.
+ P — упорядочивание процессов согласно использованию ресурсов процессора (режим по умолчанию).
+ M — упорядочивание процессов согласно использованию ресурсов памяти.
+ E — отображение сведений об использовании памяти не в КБ, а в МБ (единичная E) или ГБ (нажмите E дважды).
+ k — отправка сигнала процессу (нажмите Esc, если вы уже начали отправку сигнала, но затем передумали).

![Command Top](images/top.jpg "Работа с Top")

Самые полезные поля в выводе (над белой строкой):

+ 1-я строка: время работы (uptime; как долго уже работает компьютер) и средняя загрузка (load average).
+ 2-я строка: количество задач всего (total) и работающих (running).
+ 3-я строка: показывает текущую нагрузку на все процессоры (CPU):
  + us и sy — время процессора, используемое процессами пользователей и процессами операционной системы соответственно. В сумме с "wa" (показано ниже) дает общую нагрузку на систему.
  + id — время простоя в %; 100 означает, что система полностью свободна, 0 означает, что система полностью занята.
  + wa — время ожидания процессором медленного ввода-вывода. Высокое значение wa означает проблемы с нагрузкой на диск или иногда проблемы с сетью.
  + Примечание: 100 % означает, что ваш компьютер полностью загружен. Например, 50 % для 8-ядерного процессора может означать полную загрузку 4-х ядер.
+ 4-я строка: оперативная память (Mem) в килобайтах.
  + Самое полезное поле здесь это total, суммарный размер оперативной памяти (ОЗУ, RAM).
  + Остальные поля этой строки не так важны.
+ 5-я строка: память подкачки (swap), то есть виртуальная оперативная память, в реальности располагающаяся на диске. Также в килобайтах:
  + Поле total — текущий размер памяти подкачки (swap size).
  + Поле free — размер свободной памяти подкачки (swap size).
  + Поле avail Mem — самое информативное. Показывает, как много ОЗУ (RAM) может быть использовано приложениями, если им потребуется больше памяти.

Информация о процессах (ниже белой строки), полезные поля:

+ %CPU: % использования одного ядра процессом. 200 % означает полную загрузку процессом двух ядер.
+ %MEM: % всей ОЗУ, используемой процессом.
+ PID, USER, COMMAND: аналогично команде ps.

## Сигналы
Сигнал — это короткое сообщение, которое можно отправить процессу.
Сигналы представляют самый простой вариант взаимодействия между процессами (inter-process communication — IPC)

Чтобы отправить сигнал ЧТО (например, TERM, KILL, STOP и т. д.) процессу с идентификатором PID:
```commandline
kill [-ЧТО] PID
[-ЧТО] означает номер или название сигнала, эта опция необязательна, по умолчанию отправляется сигнал TERM. 
```

*Например, чтобы завершить процесс самым "жёстким" способом без возможности корректного завершения своей работы, можно использовать следующую команду:*
```commandline
kill -KILL PID
или
kill -9 PID
```

*Для отправки одного и того же сигнала нескольким процессам с одинаковым названием удобно применять команду killall:*
```commandline
killall [-ЧТО] [другие опции] название_процесса
```

*Для отправки одного и того же сигнала нескольким процессам, названия которых отвечают некоторым условиям, используется команда pkill.  Она похожа на команду pgrep, но отправляет сигнал ЧТО процессам, названия которых (и аргументы, если указана опция -f) соответствуют шаблону*
```commandline
pkill [-ЧТО][другие опции] название_процесса
```

### *Важные замечания о сигналах:*
+ Обычные пользователи могут отправлять сигналы только своим процессам.
+ root может отправлять сигналы всем.
+ Следует помнить: команда kill НЕ просто завершает процессы! Она отправляет сигналы.

*Поиск процессов на основе их названий, или аргументов, или других условий и отправка им сигнала.*
```commandline
ps -ef | egrep […опции…]
(в первой команде узнаем PID-ы интересующих процессов)

kill -ЧТО КАКОЙ-ТО_PID
```

*Принудительное завершение текущего сеанса оболочки без применения команд logout и exit. $$ означает идентификатор PID текущей оболочки.*
Примечание: в реальных системах Linux выполнение этой команды приведёт к потере всей истории команд текущего сеанса (она не будет сохранена в истории оболочки).
```commandline
kill -9 $$
```

*Отправка сигнала TERM всем процессам с названием java.*
```commandline
killall java
```

*Отправка сигнала TERM всем процессам, в названиях или аргументах которых содержится последовательность символов «slee» и которые запущены текущим пользователем (см. опцию -u). Конечно, будут затронуты и все процессы sleep.*
```commandline
pkill -u $USER -f slee
```

*Самые полезные сигналы (используемые на месте ЧТО) с указанием их имен и номеров:*
+ TERM (15), terminate — завершить: отправляется по умолчанию. Означает «мягкое» завершение работы процесса: вначале удаляются все временные файлы, закрываются все открытые файлы и т. д., а затем завершается работа.
+ KILL (9), kill — уничтожить: безусловное завершение работы процесса.
+ INT (2), interrupt — прервать: отправляется, когда пользователь нажимает клавиши Ctrl+C. В большинстве случаев завершает работу соответствующего процесса.
+ TSTP (20), terminal (TTY) stop — остановка посредством терминала: отправляется, когда пользователь нажимает клавиши Ctrl+Z. Предназначен для процессов, работающих в интерактивном режиме. Приостанавливает выполнение процесса.
+ STOP (19), stop — остановить: приостанавливает работу процесса аналогично TSTP, но может использоваться для любых процессов, включая демонов. Так же, как и сигнал KILL, не может быть проигноирован процессом.
+ CONT (18), continue — продолжить: отправляется, когда пользователь выполняет команду fg или bg с целью снова запустить работу процесса. Работу всех процессов, остановленных с помощью сигнала STOP, можно возобновить сигналом CONT.


## Службы (services) Linux
Служба Linux может быть представлена как "обертка" для лучшего управления приложениями. Когда приложение управляется как сервис, а не как список разрозненных процессов, гораздо проще запускать, останавливать, перезапускать, получать текущее состояние и настраивать его поведение в зависимости от событий ОС.
Служба — это некая сущность, выполняющая конкретную работу. Обычно к службам относятся серверные приложения, такие как веб-серверы Apache и Nginx, серверы баз данных, почтовые серверы и т. д.
*Проще говоря: когда пользователи запускают программу, они отвечают на вопрос "ЧТО должно быть выполнено". Сервис, построенный вокруг той же программы, отвечает на вопрос "КАК именно следует управлять этой программой"*

### Знакомство с systemd
это большой комплект программного обеспечения (ПО), ответственный за инициализацию системы и управление службами.

Systemd оперирует следующими объектами, называемыми "юнитами":
+ Службы (services) — обычно это серверное ПО, такое как веб-сервер Apache, серверы баз данных, почтовые серверы и т. д.
+ Цели (targets) — группы других юнитов (служб и т. д.), которые необходимо запускать совместно (например, в ходе запуска системы).
+ Другие (сокеты, таймеры…)

*Для настройки и отслеживания служб можно использовать следующие инструменты:*
+ Службы, добавленные к systemd вместе с их настройками (известными также как юнит-файлы), находятся в директории /etc/systemd/system и ее вложенных директориях. Обычно юнит-файлы представляют собой символьные ссылки на «настоящие» файлы, расположенные в директории /usr/lib/systemd/system.
+ Службы (service), уже «известные» systemd, а также их состояние можно просмотреть с помощью следующей команды. Она отображает информацию аналогично командам man и less:
```commandline
systemctl list-units --type=service
```
+ Чтобы посмотреть только службы, которые запущены (running) в настоящий момент, можно использовать дополнительную опцию:
```commandline
systemctl list-units --type=service --state=running
```
+ Чтобы увидеть, какие службы были запущены в ходе загрузки ОС, выполните команду, показанную ниже. «Включённые» (enabled) службы запускаются вместе с ОС. «Выключенные» (disabled) службы — не запускаются. «Статические» (static) службы запускаются без условий, их нельзя включить или выключить, как другие.
```commandline
systemctl list-unit-files --type=service
```
+ Чтобы увидеть только включенные службы, выполните следующее:
```commandline
systemctl list-unit-files --type=service --state=enabled
```
+ Проверка текущего состояния службы с названием название_службы:
```commandline
systemctl status название_службы
```
+ Узнать текущее состояние службы, относящейся к конкретному процессу. Это самый простой способ соотнести процесс, имеющий известный идентификатор PID, с соответствующей службой:
```commandline
systemctl status PID_процесса
```
+ Запуск (start), остановка (stop) и перезапуск (restart) службы:
```commandline
systemctl start название_службы
systemctl stop название_службы
systemctl restart название_службы
```
+ Включение и отключение автоматического запуска службы на этапе загрузки ОС. Опция --now используется, чтобы добавить службу в автозагрузку и одновременно запустить её или исключить из автозагрузки и одновременно остановить (в зависимости от состояния службы):
```commandline
systemctl enable|disable [--now] название_службы
```
+ Узнать настройки автоматического запуска конкретной службы:
```commandline
systemctl is-enabled название_службы
```
+ Получить более подробные сведения для каждой службы
```commandline
systemctl status название_службы
```
![Command Systemctl](images/systemctl.png "Работа с systemctl")

Значение выделенных полей описано ниже:

+ Loaded: loaded — загружены ли элементы службы в пул памяти systemd.
+ Путь к юнит-файлу службы: /usr/lib/systemd/system/java-auth.st00.service. Здесь хранятся все настройки службы.
+ Disabled: запускается ли служба в процессе загрузки ОС.
+ Active: active (running): текущее состояние службы
+ Список процессов (относящихся к этой службе) показан в виде дерева (10970, 10974).

### Journalctl: вывод журналов служб systemd
это инструмент для управления журналами служб systemd.
Для выполнения этой команды необходимы права root или включение в группу systemd-journal.

+ Просмотр всех записанных в журнал событий для службы название_службы. Данные журнала показываются так же, как и в случае с командами less и man, поэтому доступны все те же функции: поиск по шаблонам и т. п.
```commandline
journalctl -u service_name
```
+ То же самое, но с переходом к последним строкам журнала:
```commandline
journalctl  -e -u service_name
```
+ Отслеживание событий службы в реальном времени и вывод их на терминал, наподобие команды tail -f (нажмите Ctrl+C для выхода):
```commandline
journalctl -f -u service_name
```
+ Просмотр событий от нескольких служб одновременно. Эту функцию можно сочетать с другими опциями, например -f:
```commandline
journalctl -u service_name_1 -u service_name_2 ...
```


## Информация о системе и как её собирать
Узнать больше сведений о компьютере, включая имя узла.
```commandline
uname -a
```
*Выводится длинная строка вроде следующей:
Linux unixdell 5.15.0-58-generic #64~20.04.1-Ubuntu SMP Fri Jan 6 16:42:31 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux
Где первое слово это название ОС (всегда Linux на машинах с ОС Linux), затем идёт имя узла, затем версия ядра и т. д.*

### CPU (процессоры)
Есть два способа получить сведения, касающиеся процессоров:

+ Запустить команду lscpu (лучший способ).
+ Просмотреть файл /proc/cpuinfo (запасной вариант, не очень удобный, но рабочий).

Собирая информацию о процессорах, следует помнить о нескольких аспектах:

+ Все современные процессоры являются многоядерными, то есть один физический процессор содержит несколько ядер. Большинством инструментов (например, top, упомянутым в предыдущей секции) они показываются как несколько процессоров.
+ Многопоточность (когда одно физическое ядро может обрабатывать два или более потоков выполнения) удваивает (утраивает и т. д.) число ядер, показываемое многими инструментами, наподобие top.
+ Одно ядро можно встретить только на очень небольших виртуальных машинах.
+ Что касается виртуальных машин, то отображаемая модель процессора может отличаться от модели физического процессора (например, какая-либо модель Intel или AMD), на котором работает эта машина. Но это зависит от технологии виртуализации в каждом конкретном случае.
+ С точки зрения производительности наиболее интересна следующая информация:
  + Архитектура, например x86_64, i586, ARM и т. д.
  + Модель процессора
  + Частота в МГц или ГГц
  + Количество ядер

Вкратце, каждое ядро — это по большей части независимый вычислительный блок внутри процессора, способный выполнять программы самостоятельно, без взаимодействия с другими ядрами. Поэтому каждое ядро операционная система воспринимает как отдельный процессор.

Потоки: для многопоточных ядер возможно одновременное выполнение более одного процесса на ядро. Это не означает, что одно многопоточное ядро имеет такую же производительность, как два однопоточных; на самом деле, этот показатель можно приблизительно оценить как 1,5. Он зависит от процессов (и их специфики), выполняемых на каждом ядре.

Тактовая частота процессора: чем больше значение частоты в МГц, тем быстрее выполняются инструкции процессора, что приводит к повышению производительности.

Для сбора самой интересной информации из вывода команды lscpu необходимо обратить внимание на следующие поля:
+ Architecture (архитектура): в большинстве современных устройств это x86_64, но могут встречаться и другие. Например: процессор с архитектурой ARM не может выполнять программы, написанные для x86_64.
+ CPU(s) (процессор): суммарное количество потоков = количество ЦП × кол-во ядер на разъём × кол-во потоков на ядро.
+ On-line CPU(s) list (список процессоров, отображаемый в реальном времени): какие ядра доступны в текущий момент; в большинстве случаев доступны все ядра. Номера процессоров начинаются с 0.
+ Thread(s) per core: (потоков на ядро): как говорилось выше, существуют однопоточные и многопоточные процессоры. Эти сведения указываются в этом поле.
+ Core(s) per socket: (ядер на разъём): количество ядер у каждого процессора.
+ Socket(s): (разъёмы): количество процессоров (не ядер), установленных на компьютере. Для бытовых устройств, таких как настольные персональные компьютеры, ноутбуки и т. д., этот параметр почти всегда равен 1. Для мощных серверов этот параметр, как правило, превышает 1.
+ Vendor ID, Model name (идентификатор производителя, название модели): описывает модель процессора.
+ CPU MHz: (частота процессора в МГц): частота, которая может динамически варьироваться

Изучая вывод команды top, нужно обратить внимание на следующие нежелательные показатели:
+ Постоянно высокие значения полей us, sy, ni означают, что компьютер находится под высокой нагрузкой.
+ Постоянно высокое значение поля wa означает недостаточную производительность подсистемы ввода-вывода, представляемой, как правило, жёстким диском. Так что высокие значения wa не означают проблемы со слабым процессором, скорее, требуются действия с хранилищем.

### Оперативная память
Чем больше у вас памяти, тем больше приложений вы можете запустить одновременно без негативных последствий. Кроме того, многие серверные приложения используют память довольно интенсивно, так что можно сказать, что памяти почти всегда недостаточно.

В современных операционных системах используется два типа памяти:

+ RAM (ОЗУ, оперативное запоминающее устройство): это «настоящая» память.
+ Swap (память подкачки): память на диске, обычно используемая для выгрузки на диск неактивных приложений, когда ОЗУ заполнено. Она намного медленнее по сравнению с ОЗУ, поэтому если память подкачки активно используется, то работа компьютера будет также значительно замедленна. Такая же память есть и в Windows.

Объём памяти показывается командой:
```commandline
free
в килобайтах (по умолчанию)
```
Опция "-m" — для отображения в МБ. Команда free показывает общий и свободный объём как для ОЗУ, так и для памяти подкачки.

Самые интересные поля:

+ Mem (ОЗУ): total (всего) и available (доступно; то есть сколько ещё памяти доступно для приложений).
+ Swap (память подкачки): если часто используется (то есть поле used (используется) > 0), администраторам стоит задуматься об увеличении оперативной памяти.

### Другие параметры: lsblk, lsusb, lspci
В некоторых случаях также полезно собрать информацию о следующих устройствах:
+ дисковые устройства (внутренние и внешние, такие как подключённые USB-устройства флэш-памяти) — используйте команду lsblk;
+ устройства PCI, такие как сетевые интерфейсы, контроллеры Wi-Fi, видеокарты — используйте команду lspci;
+ периферийные устройства, обычно подключаемые к порту USB — запустите команду lsusb.

## Файловые системы
Каждая файловая система ОС Linux подключена к определённому месту главного «дерева» иерархии файлов и директорий. Действие по подключению файловой системы к надлежащему месту дерева называется монтированием (mounting), это специальное место называется точкой монтирования (точкой подключения, mounting point).
```commandline
mount
```

С помощью команды mount (mount — англ., монтировать, устанавливать) можно посмотреть, как физические (и виртуальные) устройства подключены к своим точкам монтирования (каждая точка монтирования — это существующая директория).
```commandline
ПРИМЕР

[st00@c7-sandbox ~]$ mount | egrep -v tmpfs | egrep /dev 
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)
/dev/mapper/rootvg-rootlv on / type ext4 (rw,relatime,seclabel,data=ordered)
mqueue on /dev/mqueue type mqueue (rw,relatime,seclabel)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,seclabel)
/dev/sda1 on /boot type ext4 (rw,relatime,seclabel,data=ordered)
/dev/mapper/rootvg-tmplv on /tmp type ext2 (rw,relatime,seclabel)
/dev/mapper/rootvg-homelv on /home type ext4 (rw,relatime,seclabel,quota,usrquota,grpquota,data=ordered)
```
*Третье «слово» каждой строки содержит соответствующую точку подключения, например /, /boot, /tmp, /home. То есть главная файловая система "/" подключена из устройства /dev/mapper/rootvg-rootlv, файловая система /boot располагается на устройстве /dev/sda1 и т. д.*

В нашем случае:
+ Файловая система с домашними директориями /home хранится на отдельном устройстве. Поэтому, даже если пользователи полностью исчерпают место на /home, сама операционная система будет в безопасности, так как переполнение не затронет её главную файловую систему (т. е. /).
+ То же касается и файловой системы /tmp, которая также часто подключается как отдельная.

### df
*Команда df ещё даже интереснее команды mount с точки зрения повседневной работы, поскольку она показывает использование дискового пространства для всех подключённых файловых систем. Поэтому если в вашей системе закончилось свободное дисковое пространство и вы получили сообщение «No space left on device» (не осталось свободного места на устройстве), то первое, что нужно запустить, это команду df.*

Стоит только упомянуть об опции -m (для использования мегабайтов) и -h (для удобного для человека формата вывода).
```commandline
ПРИМЕР

[st00@c7-sandbox ~]$ df -m | egrep -v tmpfs
Filesystem                1M-blocks  Used Available Use% Mounted on
/dev/mapper/rootvg-rootlv     22047  9515     11493  46% /
/dev/sda1                       488   246       207  55% /boot
/dev/mapper/rootvg-tmplv       4032    58      3770   2% /tmp
/dev/mapper/rootvg-homelv     25071  4409     19535  19% /home
```
*В показанном выше примере вывод команды mount очищен от ненужных в нашем случае строк, относящихся к виртуальным файловым системам tmpfs. Как мы видим, в главной файловой системе "/" есть ещё 11 ГБ свободного (Available) пространства, в /home — 19 ГБ и т. д.*
Если в файловой системе закончится место, то будут показаны сообщения об ошибках *No space left on device*

Но сообщение об ошибке «No space left on device» может быть показано, даже когда в файловой системе ещё много свободного места.
```commandline
ПРИМЕР

[st00@c7-backend shared]$ touch /mnt/testfs/shared/new.empty.file
touch: cannot touch '/mnt/testfs/shared/new.empty.file': No space left on device

[st00@c7-backend shared]$ df -h /mnt/testfs/shared
Filesystem      Size  Used Avail Use% Mounted on
/dev/loop0       93M  2.5M   84M   3% /mnt/testfs
```

Обычно в таких случаях только системные администраторы или DevOps-инженеры могут сказать, что произошло. И, скорее всего, причина будет в inode.
А что такое inode? Если коротко: для каждого файла и директории в файловой системе есть специальная отдельная запись, называемая индексным дескриптором, или inode (index node), в которой хранятся настройки прав доступа, указан владелец-пользователь и группа-владелец и другая служебная информация, называемая метаданными и метаинформацией. 

Для каждого файла и каталога необходим свой дескриптор.

Для каждого дескриптора требуется немного дискового пространства, поэтому в файловой системе может быть только ограниченное количество дескрипторов, устанавливаемое в момент создания файловой системы (создание файловой системы — это то же самое, что и форматирование диска в ОС Windows). Когда индексные дескрипторы заканчиваются, в файловой системе уже больше нельзя создавать новые объекты, и поэтому выводится сообщение об ошибке «No space left on device».

Понимая суть индексных дескрипторов, можно легко выявить причину проблемы с помощью команды df с опцией -i, означающей отображение дескрипторов inode, вместо дискового пространства:
```commandline
[st00@c7-backend shared]$ df -i /mnt/testfs
Filesystem     Inodes IUsed IFree IUse% Mounted on
/dev/loop0      25688 25688     0  100% /mnt/testfs
```
*Теперь первопричина ошибки ясна — все индексные дескрипторы уже используются (IUse% = 100 %) для существующих файлов и директорий. Такое может произойти при создании большого количества небольших файлов, например, из-за сбоя приложения или логических ошибок.*

### du
*В отличие от mount и df, эта команда не относится напрямую к файловым системам. Она подсчитывает размер директорий.*
*Для этого используется опция "-s". Также ее лучше комбинировать с опциями "-m" (показывать объем в МБ) или "-h" (размер в понятном человеку формате).*
```commandline
ПРИМЕР

[st00@c7-sandbox ~]$ du -sm ~ /tmp 2>/dev/null
174     /home/st00
1       /tmp

[st00@c7-sandbox ~]$ du -sh ~ /tmp 2>/dev/null
174M    /home/st00
800K    /tmp
```

Примечания:

+ -s означает summarize (суммировать, подводить итог), эта опция нужна, чтобы отображался только итоговый полный размера каталога. -h означает human-readable — понятный для человека.
+ Этот инструмент может посчитать размер только тех каталогов, для которых у вас есть права на чтение и выполнение, остальные будут проигнорированы с выводом сообщения об ошибке «Permission denied» (в доступе отказано).

## Архивы и сжатие
При выполнении операций сжатия с помощью gzip и bzip2 следует помнить о нескольких вещах:
+ gzip устанавливается везде, bzip2 является опциональным и может отсутствовать.
+ Они могут сжимать и распаковывать ТОЛЬКО отдельные файлы (НЕ каталоги).
+ Они могут читать ввод из stdin, т.е. действовать по принципу "что-то ... | gzip -9c > /some/where".
+ Входные файлы удаляются по умолчанию, если не указана опция "-c".
+ bzip2 сжимает лучше, чем gzip, но работает дольше.
+ Оба инструмента однопоточны, т.е. могут использовать только одно ядро процессора, а не все сразу.

Их наиболее полезные опции - общие для обоих:
+ -1...-9: степень сжатия от 1 до 9, где 1 - минимальная, 9 - максимальная.
+ -d: распаковать файл. Коэффициент сжатия здесь не требуется.
+ -с: вывести результат на stdout. Входные файлы не удаляются при использовании "-с".

Использование:
```commandline
Сжатие одного файла:

gzip -9 некий_файл

Файл, полученный на входе, удаляется, вместо него создаётся новый файл некий_файл.gz.
```

```commandline
Сжатие всех файлов *.txt в текущей директории:

gzip -9 *.txt

Все входные файлы удаляются, вместо них создаются новые файлы *.txt.gz
```

```commandline
Сжатие файла “некий_файл” и вывод результата в stdout

bzip2 -9c некий_файл > некий_файл.bz2

При работе с stdout входные файлы сохраняются
```

```commandline
Распаковка файла

bzip2 -d некий_файл .bz2

Входной файл "некий_файл.bz2" удаляется, вместо него создается "некий_файл"
```

```commandline
Распаковка с сохранением исходного файла:

gzip -dc некий_файл.gz > некий_файл

Входной файл "some_file.gz" сохраняется, так как указано "-c"
```

```commandline
Сжатие данных, поступающих из stdout другой команды:

cat *.log | bzip2 -5c > /tmp/compressed-logs.bz2

Когда эти инструменты сжатия читают входные данные из stdin через пайп, необходимо указать опцию "-c" и перенаправить их вывод в какой-либо файл; в противном случае он будет выведен в терминал (что нежелательно в большинстве ситуаций).
```

### tar
+ "tar" - это основной инструмент для создания архивов из нескольких файлов. То есть, имея на входе каталог, "tar" конкатенирует его содержимое в один файл.
+ "tar" также может создавать сжатые архивы за один раз, подобно инструменту Windows "zip".

В Windows обычные инструменты архивации, такие как zip, WinRAR, 7zip и т.д., берут папку или файл(ы) и сжимают их в архив. Вы получаете только один сжатый файл вместо многих.

В мире UNIX это работает по-другому:

+ Архив UNIX - это "склеенная" пара входных файлов и каталогов, не обязательно сжатая."tar" - основной инструмент для создания архивов.
+ Архив может быть сжат как во время, так и после его создания.
+ Для сжатия архивов могут использоваться внешние инструменты, такие как gzip и bzip2.

Основные советы для архивирования файлов в UNIX следующие:

+ Скопируйте все, что вам нужно, в отдельную, только что созданную директорию.
+ Сделайте архив этой директории. При необходимости, сожмите этот архив.
+ После извлечения где-нибудь в новой директории (или, что более вероятно, даже на другой машине), эта директория (см. шаг 2) будет хранить все исходные файлы внутри.

Наиболее полезными опциями программы "tar" являются:

+ -f /path/to/file.tar: имя входного или выходного файла
+ -с: создать архив
+ -t: вывести список его содержимого
+ -x: извлечь все объекты
+ -z: сжать архив с помощью gzip во время создания
+ -j: сжать архив с помощью bzip2 (если установлен) во время создания

```commandline
Создать архив директории можно следующим способом:

tar -c -f /путь/к/архиву.tar /некая/директория

Примечание: лучше указывать относительные пути или заранее перейти к директории /некая/директория с помощью cd, чтобы команда выглядела примерно следующим образом

tar -c -f /путь/к/архиву.tar dir
```

```commandline
Отобразить содержимое архива, то есть вывести имена файлов и директорий в стандартный поток вывода stdout:

tar -t -f /путь/к/архиву.tar
```

```commandline
Извлечь содержимое архива в текущую директорию:

tar -x -f /путь/к/архиву.tar
```

```commandline
Извлечь содержимое архива и поместить в другое место, НЕ в текущую директорию:

tar -x -f /путь/к/архиву.tar -C /новое/место

Содержимое архива будет распаковано и помещено в /новое/место. Это место должно существовать перед выполнением “tar -xf” 
```

```commandline
Архивировать каталог с помощью gzip:

tar -czf /путь/к/архиву.tar.gz некая_директория
```

```commandline
Архивировать каталог некий_каталог с помощью bzip2 (если bzip2 установлен):

tar -cjf /путь/к/архиву.tar.bz2 некая_директория
```

```commandline
Показать содержимое архива:

tar -tf /путь/к/архиву.tar.gz
или
tar -tzf /путь/к/архиву.tar.gz

Для версии tar, используемой в Linux, для извлечения или вывода содержимого опции -z и -j не нужны.
```

```commandline
Распаковать архив в текущую директорию:

tar -xf /путь/к/архиву.tar.bz2
или
tar -xjf /путь/к/архиву.tar.bz2

Для версии tar, используемой в Linux, для извлечения или вывода содержимого опции -z и -j не нужны.
```

```commandline
ПРИМЕР

# Архивирование директории с помощью gzip с использованием пайпов
tar -cf - /path/to/dir | gzip -9c > my-archive.tar.gz

# Архивирование директории с помощью bzip2 с использованием пайпов
tar -cf - /path/to/dir | bzip2 -9c > my-archive.tar.bz2

# Распаховка существующего архива с использованием пайпов
gzip -dc my-archive.tar.gz | tar -xf -
bzip2 -dc my-archive.tar.bz2 | tar -xf -
```

## Передача файлов между компьютерами с помощью протокола SCP  (Secure CoPy, или SSH CoPy)
```commandline
Отправка (т. е. загрузка) файла на компьютер с именем host, который можно указать как в виде IP-адреса, так и в виде доменного имени. Для сессии SSH и, соответственно, для отправки файла будет использоваться учётная запись someone:

scp некий_файл someone@host:/путь

В первую очередь, чтобы выполнить команду, необходимо ввести пароль для учётной записи someone. После выполнения команды этот файл появится на компьютере host в директории /путь (она обязана существовать). Название файла останется прежним (некий_файл).
```

```commandline
То же самое, но этот файл будет скопирован на компьютере host как
"/путь/другой_файл":

scp некий_файл someone@host:/путь/другой_файл

Если файл /путь/другой_файл уже существует, он будет  перезаписан содержимым файла некий_файл, так же, как и в случае с командой cp.

Помните, что перезапись целевого файла (если он существует на момент запуска команды) выполняется как при загрузке, так и при скачивании.
Важно: при перезаписи файлов никаких предупреждений не выводится. Для SCP нельзя задать поведение, аналогичное "cp -i".
```

```commandline
Для копирования всей директории со всем содержимым нужна опция "-r", так же как и для команды cp:

scp -r someone@host:/path/to/target_dir ~/

Это пример скачивания с использованием SCP.
В результате вы получите директорию “target_dir”, созданную в вашей домашней директории.
```

Заключительные замечания:

+ Если целевые файлы уже существуют, они перезаписываются!
+ Если вы хотите копировать директории, не забудьте указать опцию "-r" 
+ Команда scp не может корректно работать с символьными ссылками, поэтому если вы скопируете таковую с помощью протокола SCP, то будет скопировано всё её целевое содержимое. Если вы хотите просто сохранить копию самой символьной ссылки, то лучше поместить её сначала в архив посредством команды tar.

## Основные понятия сетей
