```commandline
/etc: файлы конфигурации для большинства приложений и некоторых частей ОС
/home: как правило, используется для хранения домашних директорий пользователей, например /home/ваше_имя_пользователя. Аналогично C:\Users в Windows.
/root: домашняя директория пользователя root (это единственный пользователь-администратор во всех UNIX-подобных ОС).

/bin: большинство исполняемых файлов (например, программ) хранится здесь. В современных версиях Linux директория /bin часто служит так называемой символьной ссылкой на директорию /usr/bin, а не "настоящей" директорией - если кратко, любая операция, затрагивающая /bin/something будет фактически выполняться на /usr/bin/что-нибудь. О подробностях работы с символьными ссылками мы поговорим позже.

/sbin: похож на /bin, но хранит специальные исполняемые файлы, служащие для конфигурации системы и обычно запускаемые только пользователем root.
/tmp: временные файлы ОС и приложений (аналог C:\Temp в ОС Windows).

/var: содержит различные файлы с кэшем системы, файлы журналов и файлы баз данных (если сервер БД установлен). Директория /var/log хранит файлы журналов системы и большинства приложений.

/usr: в настоящее время это главное место для приложений (исключая настройки, хранящиеся в /etc). Например: /usr/bin содержит исполняемые файлы, /usr/lib — разделяемые библиотеки и т. д.
```

### Формат текстовых файлов UNIX
*В UNIX-подобных ОС, включая Linux, текстовые файлы имеют свой собственный формат, отличный от Windows.*

+ Их строки заканчиваются символом '\n' (он не отображается на терминале, но все же существует), который также называется LF, его ASCII-код - 10 (0xA в шестнадцатеричной системе).
+ Символы '\r\n' играют ту же роль в Windows, символ '\r' также называется CR, его ASCII код - 13 (0xD в шестнадцатеричной системе).

Можно использовать очень простую команду "file", которая определяет формат указанных файлов
```commandline
file passwd*
passwd: 	ASCII text
passwd.win: ASCII text, with CRLF line terminators
```
*"ASCII text" показан для исходных текстовых файлов UNIX, а "ASCII text, with CRLF line terminators" для текстовых файлов Windows.*

*Чтобы преобразовать их в командной строке Linux, вы можете использовать инструменты "dos2unix" и "unix2dos" соответственно (если они, конечно, установлены).*

## Методы перенаправления вывода

### *stdout*
Представьте, что у нас есть программа, которая быстро генерирует множество выходных строк в stdout.
мы можем использовать одну из следующих техник:
```commandline
some_program > output_file_rewrite
some_program >> output_file_append

'>' перезапишет файл
'>>' добавит stdout программы к содержимому существующего файла

Например:
egrep root /etc/passwd > file.txt
```
*Оба метода создают выходной файл, если он не существовал ранее.*  
В обоих случаях, показанных выше, stdout программы будет записан в указанный файл, а не в терминал.

### *stderr*
Если вы хотите сохранить сообщения об ошибках отдельно от "полезного" вывода, можно запустить программу следующим образом:
```commandline
egrep root /no/such/file 2> file.txt
egrep root /no/such/file 2>> file.txt
```
*Важные замечания о перенаправлении stderr:*
+ Не забудьте указать '2', если вы работаете с stderr
+ Пробелы между '2' и '>' (или '>>') не допускаются, поэтому:
  + '2> файл', '2>> файл' разрешены
  + 2 > файл", "2 >> файл" являются неправильными

*'2' - это внутренний номер (или ID) потока stderr. Между тем, stdout имеет ID 1, но вам не нужно набирать '1> output_file', так как перенаправление stdout используется по умолчанию.*

### *Объединение stdout и stderr*
```commandline
some_program > output_file 2>&1

Это работает следующим образом:
-Stderr перенаправляется в stdout (порядок перенаправления - "чтение" справа налево)
-Stdout записывается в "output_file"

В результате, оба потока (stdout и stderr) будут записаны в один файл.

Пример:
egrep root /etc/passwd /no/such/file > file.txt 2>&1
```

### */dev/null*
Часто, но не всегда, лучше полностью игнорировать ошибки или stdout, и показывать только один поток. Для этих целей существует специальное псевдоустройство /dev/null - вы можете записать на него что угодно, и эта информация исчезнет, как в черной дыре.
```commandline
egrep root /no/such/file 2>/dev/null
```

Если хотите проигнорировать обычные сообщение, напишите так:
```commandline
egrep root /etc/passwd /no/such/file > /dev/null
```

## *Пайпы (pipes)*
*Пайпы (Pipes) предназначены для перенаправления stdout одной программы в stdin другой.*

![Пайпы pipes](images/pipes.png "Работа pipes")

### *stdin*
Используется для получения входных данных - как поток, а не как входной файл.

*Примеры*
```commandline
egrep user /etc/group
"egrep" просто читает входной файл. Здесь нет ничего, связанного с входными потоками
```

```commandline
cat /etc/group | egrep user
"cat" просто печатает входной файл в stdout. Затем, с помощью пайпа через '|' между "cat" и "egrep", это содержимое передается в виде потока на stdin egrep. "egrep" читает свой stdin и ищет заданный шаблон.
```

```commandline
egrep user < /etc/group
"egrep" заполняет свой stdin из файла, указанного после '<', и ищет шаблон в потоке входных данных.
```

#### *Примечание:*
не пытайтесь заполнить stdin команды через pipe и '<' одновременно. В этом случае на вход будет принят только файл, а stdout предыдущей команды будет проигнорирован. Итак:
```commandline
cmd1 | cmd2 - верно
cmd2 < /some/file - верно
cmd1 | cmd2 < /some/file - неверно, поскольку cmd2 получит на вход тольк содержимое /some/file, при этом результат cmd1 будет проигнорирован.
```

*Примеры*
```commandline
cat /etc/passwd /etc/group ~/.bash_history | egrep user
печатает все строки, содержащие "user", из нескольких файлов, объединенных программой cat

cat /etc/passwd /etc/group ~/.bash_history | egrep user | less
делает то же самое, но показывает это в постраничном представлении, обеспечиваемом"less"

egrep "cat" ~/.bash_history | sort | uniq
ищет строки, содержащие "cat" в истории команд, затем печатает только уникальные строки без дубликатов

egrep "cat" ~/.bash_history | sort | uniq | wc -l
показывает количество строк, найденных выше
```
*Важные замечания*
+ Пайпы похожи на '>' и '>>', поэтому ваш stdout НЕ будет отображаться в терминале.
+ Stdout может быть записан в файл ИЛИ передан в stdin следующей команды, но НЕ одновременно.  Поэтому НЕ ожидайте, что что-либо будет передано в "next_command" в примере ниже.
````commandline
some_command > result | next_command

поскольку stdout команды some_command уже был записан в файл "result", для заполнения stdin следующей команды (т.к. next_command) ничего не остается.
````

+ Пайпы могут работать только с stdout, поэтому
  + Если что-либо было выведено на stderr, и stderr не был обработан отдельно, вы также увидите сообщения stderr среди обработанных строк. Схематично это показано на рисунке ниже:
![Пайпы pipes](images/pipes2.png "Работа pipes")
*В этом примере 1-й stderr не обрабатывается, поэтому он выводится на терминал так же, как и результат "head".*
+ Если вы хотите работать через пайпы с stderr, можно использовать конструкцию ниже. Она объединяет stdout и stderr для "next_command":
````commandline
some_command 2>&1 | next_command
````
![Пайпы pipes](images/pipes3.png "Работа pipes")
*Пайплайн из предыдущей схемы теперь работает по-другому, так как 1-й stderr обрабатывается и объединяется с stdout.*

*Более сложная конструкция:*
````commandline
some_command 2>&1 >/dev/null | next_command

будет игнорировать stdout команды some_command, перенаправлять ее stderr в stdout и предоставлять его в качестве входных данных для "next_command". То есть, если вы хотите работать только с stderr и полностью игнорировать stdout, вы можете ее использовать.
````

Чтобы понять эти принципы, выполните команды:
````commandline
cat /etc/passwd /etc/group | egrep "no such pattern"

Ничего не выводится, поскольку:
a) stdout cat был полностью отправлен в stdin egrep 
b) egrep не нашел ни одной строки с "no such pattern".
````

````commandline
cat /etc/passwd /etc/group > /tmp/result.file | egrep "user"

stdout cat был полностью записан в /tmp/result.file, поэтому egrep принимал пустые входные данные. Если же вы запустите
cat /etc/passwd /etc/group | egrep "user"
некоторые строки с высокой долей вероятности будут напечатаны.
````

*Теперь stderr и пайпы:*
````commandline
cat /etc/passwd /etc/group /no/such/file1 /no/such/file2 | egrep root | head -n 2

Вы, вероятно, ожидаете только 2 строки в выводе (из-за "head -n 2"), но на самом деле увидите четыре: две "паразитные" строки с ошибками "No such file or directory" (потому что они были выведены на stderr, сам stderr не был ни перенаправлен, ни проигнорирован) и две "нормальные" строки, в которых найдется шаблон.
````

````commandline
cat /etc/passwd /etc/group /no/such/file1 /no/such/file2 2>&1 | egrep "No such file or directory" | head -n 2

Эта конструкция печатает только 2 первые строки, содержащие подстроку "No such file or directory", найденные в объединенных stdout и stderr cat, другие строки не печатаются, и это ожидаемое поведение (поскольку поток ошибок был объединен со стандартным выводом).
````
## Учетные записи ОС
````text
В UNIX-подобных операционных системах существует несколько типов пользователей ОС (т.е. учетных записей):

Стандартные учетные записи: создаются для обычных пользователей
Административная учетная запись: ее имя - root, и она является единственным администратором ОС (у вас не может быть двух root). Учетная запись root используется для прямого входа в систему очень редко; вместо этого администраторы временно повышают свои привилегии до root для обслуживания системы и других важных операций.
Служебные учетные записи: создаются для служб и других специальных целей; не должны использоваться пользователями. Например, для запуска бэкэнд-приложения (или приложения сервера базы данных) должна использоваться отдельная учетная запись.  Это минимизирует возможные последствия в случае сбоя или взлома приложения.
````
### *В чем разница:*
````text


Стандартные учетные записи: могут входить в систему, выполнять команды и читать некоторые файлы или директории. Они не могут изменять любую часть ОС и "общесистемных" приложений. По умолчанию они могут изменять данные только в своих домашних директориях и /tmp.
Административная (root) учетная запись: может входить в систему и делать все с ОС и пользователями без каких-либо ограничений (в отличие от Windows, где учетная запись администратора не настолько мощная, как учетная запись "Локальная система").
Служебные учетные записи: не могут входить в систему. ОС, службы и приложения (запускаемые root) используют их для специальных целей, например, для запуска определенных программ, служб и т.д.
````

### Основные настройки учетной записи: /etc/passwd
/etc/passwd - это основной конфигурационный файл для учетных записей пользователей, который используется, когда:
+ Пользователь входит в систему по SSH, FTP и другим средствам/протоколам.
+ ОС или любая программа требует, чтобы имя пользователя было сопоставлено с числовым UID (см. ниже) или наоборот.
+ Что вы можете видеть относительно своей учетной записи: (помните, "${USER}" означает ваше имя пользователя)

````commandline
[feodor@c7-sandbox ~]$ egrep "${USER}" /etc/passwd
feodor:x:1000:100:User Description Here:/home/feodor:/bin/bash
````
Рассмотрим содержимое и формат этого файла. В качестве разделителя полей используется ':', таким образом:
+ feodor - имя пользователя, должно быть уникальным
+ x - поле не используется, поэтому мы имеем здесь 'x' как заглушку
+ 1000 - идентификатор пользователя, называемый "UID", должен быть уникальным. Пользователи в основном имеют UID >= 1000. Пользователь root всегда имеет UID 0. Учетные записи служб имеют UID от 1 до (в основном) 999. Никто, кроме root, не должен иметь UID 0.
+ 100 - идентификатор основной группы. Каждый пользователь должен быть членом хотя бы одной группы (не существует пользователей "без групп"). Если пользователей нужно включить в большее количество групп, это настраивается в /etc/group (см. следующий раздел).
+ User Description Here - это поле может быть пустым или содержать что угодно, кроме ':'. Оно не играет никакой роли в ОС и механизмах входа в систему.
+ /home/feodor - домашний каталог пользователя; вы автоматически помещаетесь сюда после успешного входа в систему
+ /bin/bash - программа, выполняемая при успешном входе в систему. Сервисные учетные записи не предназначены для входа в систему и работы в командной строке, поэтому у них здесь указаны специальные "псевдо" программы, такие как /bin/false или /sbin/nologin

### *Заметки по безопасности/стабильности:*

+ Только root может изменять /etc/passwd - иначе хакеры могут повысить привилегии, создав "фальшивого рута" с UID 0.
+ Любой пользователь или приложение должны иметь доступ на чтение к этому файлу - иначе ОС становится нестабильной.
+ Хеши паролей хранятся в файле /etc/shadow, доступ к которому имеет только root. Несколько слов о хэшах: это набор однонаправленных криптографических функций, таких как хорошо известные MD5, SHA-512 и т.д. Если кто-то (например, вы или ОС) знает исходный пароль, он может быть легко преобразован в хэш. Но если вы знаете только хэш, получить начальный пароль будет очень сложно.
+ Эти особые разрешения /etc/shadow используются для того, чтобы избежать атак методом перебора. В противном случае любой может прочитать хэши, а затем попытаться подобрать правильный пароль к определенному хэшу. Файл /etc/shadow также содержит все настройки паролей учетных записей ОС, например, когда пароль должен быть изменен и т.д.

## Группы ОС
+ Группы включают несколько (0 или более) пользователей для упрощения управления пользователями и разделения привилегий
+ Каждый пользователь должен быть членом как минимум одной группы - она задается в /etc/passwd, такая группа называется "основной" для конкретного пользователя
+ Каждый пользователь может быть включен в 0 или более дополнительных групп, называемых "вторичными группами" (secondary groups). Членство во вторичных группах настраивается в файле /etc/group.
+ Нет никакой разницы (в плане привилегий) между членством в первичной и вторичной группах, например: если ваш пользователь входит в группу "qa" и группу "users", вы можете читать файлы, доступные как группам "qa", так и "users".
+ Группы полезны для назначения разрешений на доступ к файлам и других привилегий или ограничений, например:
  + кто может читать/писать/исполнять файл
  + кто может войти в систему через SSH
  + кто и как может использовать инструменты "sudo" или "su"
  + кто может читать журналы общесистемных служб с помощью инструмента "journalctl"
  + сколько процессора/памяти/дискового пространства может быть израсходовано

#### *Заметки*
+ Имена групп чувствительны к регистру, как и почти все в мире UNIX. т.е. группы "users" и "Users" - это разные группы.
+ В отличие от Windows, в UNIX нет группы "Администраторы".
+ В большинстве систем членство в группе "root" не дает многих привилегий, в отличие от статуса пользователя "root".
+ Могут существовать специальные группы с дополнительными привилегиями, это сильно зависит от настроек вашей ОС. Например, группы "sudo" или "wheel" могут иметь (а могут и не иметь) неограниченные права на выполнение любых команд от имени root через "sudo".

### *Основные настройки групп: /etc/group*
+ ОС или какой-либо программе требуется преобразовать имя группы в числовой GID (см. ниже) или наоборот.
+ Пользователь пытается сделать что-то, что может быть ограничено или разрешено функциями управления группами (например, чтение файла)
+ [опционально, если службы входа настроены таким образом] Пользователь входит в систему (SSH, FTP, другие протоколы).

Если вы посмотрите в /etc/group и найдете свое имя пользователя, вы можете увидеть что-то вроде этого:
````commandline
[feodor@c7-sandbox ~]$ egrep "$USER" /etc/group
wheel:x:10:feodor
users:x:100:feodor,[ ... a lot of users here ... ]
feodor:x:1000:
qa:x:1001:feodor,user1,user2
````

Рассмотрим последнюю строку примера выше:
+ Название группы
+ Всегда 'x'
+ Идентификатор группы, называемый "GID", должен быть уникальным
+ Список членов группы, разделенный запятыми, может быть пустым

Показать только UID текущего пользователя и ничего больше:
````commandline
[feodor@c7-sandbox ~]$ id -u
1000
````

Показать только GID или только имена групп текущего пользователя:
````commandline
[feodor@c7-sandbox ~]$ id -G
1000 10 100 987 1001
[feodor@c7-sandbox ~]$ id -Gn
feodor wheel users docker qa
````

Еще один способ получить имена групп:
````commandline
[feodor@c7-sandbox ~]$ groups
feodor wheel users docker qa
````

## "su": Переключить пользователя
Команда su используется для запуска оболочки от имени другого пользователя (по умолчанию root) после предоставления пароля пользователя.
Чтобы вернуться к предыдущему пользователю, выполните команду "exit".

Выполнение команды (или нескольких команд) от имени root, без запуска полнофункционального сеанса оболочки root:
````commandline
[st00@c7-sandbox ~]$ su - -c "id -u; whoami"
Password:
0
root
````
Всегда лучше использовать "su -" вместо "su", так как ключ "-" загружает все окружение оболочки целевого пользователя.

## "sudo": Substitute User Do
Инструмент sudo используется для запуска команды от имени другого пользователя (по умолчанию root) после предоставления пароля. "sudo" может быть настроен на разрешение или запрет выполнения определенных команд и их аргументов.

### *"sudo" обычно может использоваться как:*
````commandline
# Чтобы проверить возможности пользователя
sudo -l

# Чтобы запустить команды
sudo [-u username] command args
````
Где:
+ -u имя пользователя: какой пользователь будет выполнять эту команду (по умолчанию root, если не указано)
+ -l (строчная буква "L"): чтобы увидеть, какие команды вы можете выполнять
command, args - что выполнить с привилегиями другого пользователя

![Sudo](images/sudo.jpg "Работа с Sudo")

## sudo VS su: Основные различия
|                                     | su                                                                                                                               | sudo                                                                                                                                                     |
|-------------------------------------|----------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| Основная функциональность           | Предоставление оболочки входа в систему с привилегиями целевого пользователя, по умолчанию root                                  | Выполнение одной команды от имени целевого пользователя, по умолчанию root                                                                               |
| Основная идея                       | Работа в полнофункциональной оболочке как root или любой другой пользователь ОС                                                  | Делегирование некоторых административных полномочий обычным пользователям                                                                                |
| Какой пароль вводить                | Пароль целевого пользователя                                                                                                     | Ваш собственный пароль                                                                                                                                   |
| Необходимые настройки               | Возможно, вас нужно будет включить в специальную группу для запуска "su" (если это установлено вашим системным администратором). | Точные команды и даже их аргументы могут быть разрешены в явном виде                                                                                     |
| Настройки безопасности по умолчанию | Любой может выполнить команду "su", требуется только пароль целевого пользователя                                                | Только члены специфической для дистрибутива группы ("wheel" в RHEL-системах, например CentOS, "sudo" в Debian, например Ubuntu) могут использовать sudo. |

