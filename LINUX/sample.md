```commandline
ls -a
cd ../..
```

```commandline
id

Выводит сведения о текущем пользователе
Вывод: uid=0(root) gid=0(root)
```

```commandline
uname

Выводит название ОС
Вывод: Linux
```

*Простая команда UNIX с аргументами выглядит следующим образом:*
```commandline
команда [опции] [другие параметры]

(Квадратные скобки […] означают, что аргумент необязателен.)
```

```commandline
/etc: файлы конфигурации для большинства приложений и некоторых частей ОС
/home: как правило, используется для хранения домашних директорий пользователей, например /home/ваше_имя_пользователя. Аналогично C:\Users в Windows.
/root: домашняя директория пользователя root (это единственный пользователь-администратор во всех UNIX-подобных ОС).

/bin: большинство исполняемых файлов (например, программ) хранится здесь. В современных версиях Linux директория /bin часто служит так называемой символьной ссылкой на директорию /usr/bin, а не "настоящей" директорией - если кратко, любая операция, затрагивающая /bin/something будет фактически выполняться на /usr/bin/что-нибудь. О подробностях работы с символьными ссылками мы поговорим позже.

/sbin: похож на /bin, но хранит специальные исполняемые файлы, служащие для конфигурации системы и обычно запускаемые только пользователем root.
/tmp: временные файлы ОС и приложений (аналог C:\Temp в ОС Windows).

/var: содержит различные файлы с кэшем системы, файлы журналов и файлы баз данных (если сервер БД установлен). Директория /var/log хранит файлы журналов системы и большинства приложений.

/usr: в настоящее время это главное место для приложений (исключая настройки, хранящиеся в /etc). Например: /usr/bin содержит исполняемые файлы, /usr/lib — разделяемые библиотеки и т. д.
```

### Формат текстовых файлов UNIX
*В UNIX-подобных ОС, включая Linux, текстовые файлы имеют свой собственный формат, отличный от Windows.*

+ Их строки заканчиваются символом '\n' (он не отображается на терминале, но все же существует), который также называется LF, его ASCII-код - 10 (0xA в шестнадцатеричной системе).
+ Символы '\r\n' играют ту же роль в Windows, символ '\r' также называется CR, его ASCII код - 13 (0xD в шестнадцатеричной системе).

Можно использовать очень простую команду "file", которая определяет формат указанных файлов
```commandline
file passwd*
passwd: 	ASCII text
passwd.win: ASCII text, with CRLF line terminators
```
*"ASCII text" показан для исходных текстовых файлов UNIX, а "ASCII text, with CRLF line terminators" для текстовых файлов Windows.*

*Чтобы преобразовать их в командной строке Linux, вы можете использовать инструменты "dos2unix" и "unix2dos" соответственно (если они, конечно, установлены).*

## Методы перенаправления вывода

### *stdout*
Представьте, что у нас есть программа, которая быстро генерирует множество выходных строк в stdout.
мы можем использовать одну из следующих техник:
```commandline
some_program > output_file_rewrite
some_program >> output_file_append

'>' перезапишет файл
'>>' добавит stdout программы к содержимому существующего файла

Например:
egrep root /etc/passwd > file.txt
```
*Оба метода создают выходной файл, если он не существовал ранее.*  
В обоих случаях, показанных выше, stdout программы будет записан в указанный файл, а не в терминал.

### *stderr*
Если вы хотите сохранить сообщения об ошибках отдельно от "полезного" вывода, можно запустить программу следующим образом:
```commandline
egrep root /no/such/file 2> file.txt
egrep root /no/such/file 2>> file.txt
```
*Важные замечания о перенаправлении stderr:*
+ Не забудьте указать '2', если вы работаете с stderr
+ Пробелы между '2' и '>' (или '>>') не допускаются, поэтому:
  + '2> файл', '2>> файл' разрешены
  + 2 > файл", "2 >> файл" являются неправильными

*'2' - это внутренний номер (или ID) потока stderr. Между тем, stdout имеет ID 1, но вам не нужно набирать '1> output_file', так как перенаправление stdout используется по умолчанию.*

### *Объединение stdout и stderr*
```commandline
some_program > output_file 2>&1

Это работает следующим образом:
-Stderr перенаправляется в stdout (порядок перенаправления - "чтение" справа налево)
-Stdout записывается в "output_file"

В результате, оба потока (stdout и stderr) будут записаны в один файл.

Пример:
egrep root /etc/passwd /no/such/file > file.txt 2>&1
```

### */dev/null*
Часто, но не всегда, лучше полностью игнорировать ошибки или stdout, и показывать только один поток. Для этих целей существует специальное псевдоустройство /dev/null - вы можете записать на него что угодно, и эта информация исчезнет, как в черной дыре.
```commandline
egrep root /no/such/file 2>/dev/null
```

Если хотите проигнорировать обычные сообщение, напишите так:
```commandline
egrep root /etc/passwd /no/such/file > /dev/null
```

## *Пайпы (pipes)*
*Пайпы (Pipes) предназначены для перенаправления stdout одной программы в stdin другой.*

![Пайпы pipes](images/pipes.png "Работа pipes")

### *stdin*
Используется для получения входных данных - как поток, а не как входной файл.

*Примеры*
```commandline
egrep user /etc/group
"egrep" просто читает входной файл. Здесь нет ничего, связанного с входными потоками
```

```commandline
cat /etc/group | egrep user
"cat" просто печатает входной файл в stdout. Затем, с помощью пайпа через '|' между "cat" и "egrep", это содержимое передается в виде потока на stdin egrep. "egrep" читает свой stdin и ищет заданный шаблон.
```

```commandline
egrep user < /etc/group
"egrep" заполняет свой stdin из файла, указанного после '<', и ищет шаблон в потоке входных данных.
```

#### *Примечание:*
не пытайтесь заполнить stdin команды через pipe и '<' одновременно. В этом случае на вход будет принят только файл, а stdout предыдущей команды будет проигнорирован. Итак:
```commandline
cmd1 | cmd2 - верно
cmd2 < /some/file - верно
cmd1 | cmd2 < /some/file - неверно, поскольку cmd2 получит на вход тольк содержимое /some/file, при этом результат cmd1 будет проигнорирован.
```

*Примеры*
```commandline
cat /etc/passwd /etc/group ~/.bash_history | egrep user
печатает все строки, содержащие "user", из нескольких файлов, объединенных программой cat

cat /etc/passwd /etc/group ~/.bash_history | egrep user | less
делает то же самое, но показывает это в постраничном представлении, обеспечиваемом"less"

egrep "cat" ~/.bash_history | sort | uniq
ищет строки, содержащие "cat" в истории команд, затем печатает только уникальные строки без дубликатов

egrep "cat" ~/.bash_history | sort | uniq | wc -l
показывает количество строк, найденных выше
```
*Важные замечания*
+ Пайпы похожи на '>' и '>>', поэтому ваш stdout НЕ будет отображаться в терминале.
+ Stdout может быть записан в файл ИЛИ передан в stdin следующей команды, но НЕ одновременно.  Поэтому НЕ ожидайте, что что-либо будет передано в "next_command" в примере ниже.
````commandline
some_command > result | next_command

поскольку stdout команды some_command уже был записан в файл "result", для заполнения stdin следующей команды (т.к. next_command) ничего не остается.
````

+ Пайпы могут работать только с stdout, поэтому
  + Если что-либо было выведено на stderr, и stderr не был обработан отдельно, вы также увидите сообщения stderr среди обработанных строк. Схематично это показано на рисунке ниже:
![Пайпы pipes](images/pipes2.png "Работа pipes")
*В этом примере 1-й stderr не обрабатывается, поэтому он выводится на терминал так же, как и результат "head".*
+ Если вы хотите работать через пайпы с stderr, можно использовать конструкцию ниже. Она объединяет stdout и stderr для "next_command":
````commandline
some_command 2>&1 | next_command
````
![Пайпы pipes](images/pipes3.png "Работа pipes")
*Пайплайн из предыдущей схемы теперь работает по-другому, так как 1-й stderr обрабатывается и объединяется с stdout.*

*Более сложная конструкция:*
````commandline
some_command 2>&1 >/dev/null | next_command

будет игнорировать stdout команды some_command, перенаправлять ее stderr в stdout и предоставлять его в качестве входных данных для "next_command". То есть, если вы хотите работать только с stderr и полностью игнорировать stdout, вы можете ее использовать.
````

Чтобы понять эти принципы, выполните команды:
````commandline
cat /etc/passwd /etc/group | egrep "no such pattern"

Ничего не выводится, поскольку:
a) stdout cat был полностью отправлен в stdin egrep 
b) egrep не нашел ни одной строки с "no such pattern".
````

````commandline
cat /etc/passwd /etc/group > /tmp/result.file | egrep "user"

stdout cat был полностью записан в /tmp/result.file, поэтому egrep принимал пустые входные данные. Если же вы запустите
cat /etc/passwd /etc/group | egrep "user"
некоторые строки с высокой долей вероятности будут напечатаны.
````

*Теперь stderr и пайпы:*
````commandline
cat /etc/passwd /etc/group /no/such/file1 /no/such/file2 | egrep root | head -n 2

Вы, вероятно, ожидаете только 2 строки в выводе (из-за "head -n 2"), но на самом деле увидите четыре: две "паразитные" строки с ошибками "No such file or directory" (потому что они были выведены на stderr, сам stderr не был ни перенаправлен, ни проигнорирован) и две "нормальные" строки, в которых найдется шаблон.
````

````commandline
cat /etc/passwd /etc/group /no/such/file1 /no/such/file2 2>&1 | egrep "No such file or directory" | head -n 2

Эта конструкция печатает только 2 первые строки, содержащие подстроку "No such file or directory", найденные в объединенных stdout и stderr cat, другие строки не печатаются, и это ожидаемое поведение (поскольку поток ошибок был объединен со стандартным выводом).
````

