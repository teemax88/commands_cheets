```python
# Декоратор - это функция, которая в качестве аргумента принимает другую функцию и возвращает функцию-замыкание.
# Декораторы нужны для расширения функционала переданной функции за счет обертки в замыкании
def decorator(func):  # это функция, которая в качестве аргумента принимает другую функцию (со строки 11)
    def inner(*args, **kwargs):  # поскольку мы не знаем сколько мы будем вызывать (из say или bye),то лучше *args
        print('<h1>')  # открытие тега
        func(*args, **kwargs)  # или func(input('Введите ваше имя: '))
        print('</h1>')  # закрытие тега

    return inner  # возвращает функцию-замыкание.


def say(surname, name):
    print('Hello', surname, name)


say = decorator(say)  # присвоили в функцию say действие функции decorator в которую передали значение от старой функции
# say в 12-й строке действие которой выполнится в 6-й строке при её вызове
say('Асмоловский', 'Андрей')  # <h1>  Hello Асмоловский Андрей  </h1>


def bye(surname, name):
    print('Bye', surname, name)


bye = decorator(bye)  # сделали тоже самое что в 16-й строке, но значение передали с 21-й строки
bye('Асмоловская', 'Кристина')  # <h1>  Bye Асмоловская Кристина  </h1>


def table(func):
    def inner(*args, **kwargs):
        print('<table>')  # открытие тега
        func(*args, **kwargs)
        print('</table>')  # закрытие тега

    return inner


# можно на 1-у функцию "повесить" несколько декораторов
povesa = decorator(table(say))  # сделает сначала table а потом его результат выведет в 6-й строке в decorator
povesa('Asmolovkii', 'Andrey')  # <h1> <table> Hello Asmolovkii Andrey </table> </h1>
# если перед функцией поставить например say сделать это, то она атоматом обвернёт эту функцию :
# @decorator
# @table если написать несколько то будет их обворачивать по очереди до написанной функции
# say = decorator(table(say))
# say('Асмоловский', 'Андрей')

```

```python
# Декоратор - это функция, которая в качестве аргумента принимает другую функцию и возвращает функцию-замыкание.
# Декораторы нужны для расширения функционала переданной функции за счет обертки в замыкании.
# Но при обычном создании декораторы вы потеряете имя свой оригинальной функции, и также ее документацию.
# В видео я покажу как сохранить имя декорируемой функции и строку документации
from functools import wraps


def decor(func):
    @wraps(func)  # будет отображать данные как если бы были строки 15,16
    def inside(*args, **kwargs):
        print('1 decor')
        func(*args, **kwargs)
        print(('2 decor'))

    # inside.__name__ = func.__name__  # в этой строке и ниже (до return) можно сказать что имя и докум.будут с func(Name)
    # inside.__doc__ = func.__doc__    или то что мы сделали в 5-й и 9-й строке
    return inside


@decor  # повесили функцию Name внутрь функции decor
def Name(surname, name):
    """
    Функция передаёт привет фамилия имя
    :param surname:
    :param name:
    :return:
    """
    print('Hello ', surname, name)


Name('Asm', "And")  # 1 decor  Hello  Asm And  2 decor

help(Name)  # вывод данных о ней

```