```python
# Декоратор - это функция, которая в качестве аргумента принимает другую функцию и возвращает функцию-замыкание.
# Декораторы нужны для расширения функционала переданной функции за счет обертки в замыкании
def decorator(func):  # это функция, которая в качестве аргумента принимает другую функцию (со строки 11)
    def inner(*args, **kwargs):  # поскольку мы не знаем сколько мы будем вызывать (из say или bye),то лучше *args
        print('<h1>')  # открытие тега
        func(*args, **kwargs)  # или func(input('Введите ваше имя: '))
        print('</h1>')  # закрытие тега

    return inner  # возвращает функцию-замыкание.

def say(surname, name):
    print('Hello', surname, name)

say = decorator(say)  # присвоили в функцию say действие функции decorator в которую передали значение от старой функции
# say в 12-й строке действие которой выполнится в 6-й строке при её вызове
say('Асмоловский', 'Андрей')  # <h1>  Hello Асмоловский Андрей  </h1>

def bye(surname, name):
    print('Bye', surname, name)

bye = decorator(bye)  # сделали тоже самое что в 16-й строке, но значение передали с 21-й строки
bye('Асмоловская', 'Кристина')  # <h1>  Bye Асмоловская Кристина  </h1>

def table(func):
    def inner(*args, **kwargs):
        print('<table>')  # открытие тега
        func(*args, **kwargs)
        print('</table>')  # закрытие тега

    return inner

# можно на 1-у функцию "повесить" несколько декораторов
povesa = decorator(table(say))  # сделает сначала table а потом его результат выведет в 6-й строке в decorator
povesa('Asmolovkii', 'Andrey')  # <h1> <table> Hello Asmolovkii Andrey </table> </h1>
# если перед функцией поставить например say сделать это, то она атоматом обвернёт эту функцию :
# @decorator
# @table если написать несколько то будет их обворачивать по очереди до написанной функции
# say = decorator(table(say))
# say('Асмоловский', 'Андрей')
```

```python
# Декоратор - это функция, которая в качестве аргумента принимает другую функцию и возвращает функцию-замыкание.
# Декораторы нужны для расширения функционала переданной функции за счет обертки в замыкании.
# Но при обычном создании декораторы вы потеряете имя свой оригинальной функции, и также ее документацию.
# В видео я покажу как сохранить имя декорируемой функции и строку документации
from functools import wraps

def decor(func):
    @wraps(func)  # будет отображать данные как если бы были строки 15,16
    def inside(*args, **kwargs):
        print('1 decor')
        func(*args, **kwargs)
        print(('2 decor'))

    # inside.__name__ = func.__name__  # в этой строке и ниже (до return) можно сказать что имя и докум.будут с func(Name)
    # inside.__doc__ = func.__doc__    или то что мы сделали в 5-й и 9-й строке
    return inside


@decor  # повесили функцию Name внутрь функции decor
def Name(surname, name):
    """
    Функция передаёт привет фамилия имя
    :param surname:
    :param name:
    :return:
    """
    print('Hello ', surname, name)

Name('Asm', "And")  # 1 decor  Hello  Asm And  2 decor

help(Name)  # вывод данных о ней
```

## Декораторы
это мощный инструмент, который позволяет изменять поведение функций или методов без изменения их исходного кода. Они используются для добавления функциональности к существующим функциям или методам. Декораторы часто используются, например, для логирования, проверки прав доступа, кэширования и других аспектов программы.

## Шаг 1: Создание простого декоратора
*Декоратор - это функция, которая принимает другую функцию в качестве аргумента и возвращает новую функцию. Вот пример простого декоратора:*
```python
def my_decorator(func):
    def wrapper():
        print("Что-то происходит перед вызовом функции")
        func()
        print("Что-то происходит после вызова функции")
    return wrapper
```

## Шаг 2: Использование декоратора
*Теперь мы можем использовать этот декоратор, чтобы изменить поведение другой функции. Декорируем функцию с помощью "@" перед именем декоратора:*
```python
@my_decorator
def say_hello():
    print("Привет, мир!")

say_hello()
```

*Этот код вызовет следующий вывод:*
```python
Что-то происходит перед вызовом функции
Привет, мир!
Что-то происходит после вызова функции
```

## Шаг 3: Передача аргументов в декоратор и обернутую функцию
*Чтобы сделать декоратор более полезным, мы можем передавать аргументы как в сам декоратор, так и в обернутую функцию:*
```python
def repeat_twice(func):
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        func(*args, **kwargs)
    return wrapper

@repeat_twice
def greet(name):
    print(f"Привет, {name}!")

greet("Анна")
```

*Этот код вызовет следующий вывод:*
```python
Привет, Анна!
Привет, Анна!
```

## Шаг 4: Декораторы с параметрами
*Мы также можем создавать декораторы с параметрами. В этом случае, мы создаем две вложенные функции:*
```python
def repeat(num):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(num):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def say_hi():
    print("Привет!")

say_hi()
```

*Этот код вызовет следующий вывод:*
```python
Привет!
Привет!
Привет!
```