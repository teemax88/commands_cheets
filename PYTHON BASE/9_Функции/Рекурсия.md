*Рекурсия в Python - это концепция, которая позволяет функции вызывать саму себя. Это мощный метод решения задач, когда задача может быть разбита на более мелкие подзадачи того же типа. Рекурсия часто используется для решения задач, связанных с деревьями, списками и другими структурами данных, которые могут быть рассмотрены как набор подзадач.*

*Основным элементом рекурсивной функции является базовый случай (base case) и рекурсивный случай (recursive case). Базовый случай определяет условие завершения рекурсии и предотвращает бесконечное выполнение функции. Рекурсивный случай описывает, как задача разбивается на более мелкие подзадачи и как функция вызывает саму себя для их решения.*

*Вот простой пример рекурсивной функции в Python, вычисляющей факториал числа:*
```python
def factorial(n):
    # Базовый случай: факториал 0 равен 1
    if n == 0:
        return 1
    # Рекурсивный случай: факториал числа n равен n умножить на факториал (n-1)
    else:
        return n * factorial(n - 1)
```

*Когда мы вызываем factorial(5), функция делает следующие вызовы:*
```text
factorial(5) возвращает 5 * factorial(4)
factorial(4) возвращает 4 * factorial(3)
factorial(3) возвращает 3 * factorial(2)
factorial(2) возвращает 2 * factorial(1)
factorial(1) возвращает 1 * factorial(0)
factorial(0) достигнут базовый случай и возвращает 1.
```

*Затем все эти значения комбинируются в обратном порядке:*
```text
factorial(0) возвращает 1, затем factorial(1) возвращает 1 * 1 = 1, затем factorial(2) возвращает 2 * 1 = 2, и так далее. В конечном итоге factorial(5) возвращает 5 * 4 * 3 * 2 * 1 = 120.
```

## Еще примеры

```python
# def recusion(x):  # рекурсия от 1
#     print(x)
#     recusion(x + 1)  # рекурсия вызовется снова от 2 и закончиться после цикла в 996 раз
# recusion(1)
```

```python
""" вывод у рекурсии должен быть выход """
def recusion(x):  # рекурсия от 1
    if x < 4:  # если условие не выполнится, то выход из рекурсии
        print(x)
        recusion(x + 1)
        print(x)

# вывод будет 1 2 3 3 2 1, сначала в 8-й строке напечатает 1, потом вызов функции в 9-й со значением 2 и после проверки
# печатаем в 8-й 2, потом вызов функции в 9-й со значением 3 и после проверки печатаем в 8-й 3, потом вызов функции
# в 9-й со значением 4 и так как проверку не прошли напечатаем в 10-й 3(разморозка рекурсии функции в 9й),
# 2(разморозка -//- ), 1(разморозка -//- )
recusion(1)
```

```python
def factorial(x):  # посчитаем факториал через рекурсию
    if x == 1:
        return 1
    return factorial(x - 1) * x

print(factorial(4))  # 24
```

```python
# числа Fibonacci состоят из 0,1 и далее следующее число складывается из 2-х предидущих
def Fibonacci(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return Fibonacci(n - 1) + Fibonacci(n - 2)  # if n > 2: останутся эти случаи

print(Fibonacci(7))  # ответ 13
# порядковый номер 0 1 2 3 4 5 6 7
# число Фибоначи   0 1 1 2 3 5 8 13
```

```python
# палиндром это такая строка которая читается слева направо и справа налево одинаково
# шалаш,  asdffdsa ,' ',  'a'
def palindrom(s):
    if len(s) <= 1:
        return True
    if s[0] != s[-1]:
        return False
    return palindrom(s[1:-1])

print(palindrom('asdffdsa'))  # True
print(palindrom('asdffdgh'))  # False
```

```python
# # функция запишет в скобки (от центра ( , и после центра ) )
# def recursion(x):
#     if len(x) <= 2:  # точка выхода из рекурсии
#         return x
#     return x[0] + '(' + recursion(x[1:-1]) + ')' + x[-1]  # запись результата
#
#
# x = input()  # фываапФВЦЙФ
# print(recursion(x))  # ф(ы(в(а(а(п)Ф)В)Ц)Й)Ф
```

```python
# функция возводит число в степень
def stepen(x, n):
    if n == 0:
        return 1
    if n < 0:  # если степень отрицательная
        return 1 / stepen(x, abs(n))
    if n % 2 == 0:
        return stepen(x, n // 2) * stepen(x, n // 2)
    if n % 2 != 0:
        return stepen(x, n - 1) * x


print(stepen(5, 4))  # 625
print(stepen(5, -3))  # 0.008
```

```python
# создадим функцию которая будет показывать на каком уровне вложенные списки
def vl_spiski(w, level=1):
    print(*w, 'Level = ', level)
    for i in w:
        if type(i) is list:
            vl_spiski(i, level + 1)


w = [1, 23, [3, 4, [3]], [2, 4, 8, [33, 12], 12, 34]]
vl_spiski(w)
# 1 23 [3, 4, [3]] [2, 4, 8, [33, 12], 12, 34] Level =  1
# 3 4 [3] Level =  2
# 3 Level =  3
# 2 4 8 [33, 12] 12 34 Level =  2
# 33 12 Level =  3
```

## Рекурсивный обход файлов
```python
import os

# path = 'D:\\Сайт\\Фото'  # лучше сделать \\ чтобы не появился служебный символ например \n

# print(path)  # вывод нашего пути D:\Сайт\Фото
# print(os.listdir(path))  # вывод подпапок ['Двери', 'Ламинат', 'Плинтус', 'Пробный.txt', 'Фон сайта', 'Ю-пласт']
# for i in os.listdir(path):  # вывод каждого элемента отдельно с его типом
#     print(i, type(i), path + '\\' + i, os.path.isdir(path + '\\' + i))  # Двери <class 'str'> D:\Сайт\Фото\Двери  и т.д.

# в выводе = i-элемент, type(i)-его тип, path + '\\' + i - наш путь+\+элемент, os.path.isdir(какой полный путь) -
# проверка является ли элемент папкой (os.path.isfile - является файлом) = True или False

# функция которая продемонстрирует подпапки и входы, выходы из неё
path = 'C:\PYTON\Пример Рекурсивный обход файлов'

def DIR(path, level=1):
    print('Путь', path, 'с уровнем', level)
    for i in os.listdir(path):
        # print('Элемент', path + '\\' + i, 'на уровне', level + 1)
        if os.path.isdir(path + '\\' + i):
            print('Спуск на уровень ниже в папку', path + '\\' + i, 'на уровень', level + 1)
            DIR(path + '\\' + i, level + 1)
            print('Возврат на уровень выше в папку', path + '\\' + i, 'на уровень', level + 1)

DIR(path)
```

## Рекурсия с сайта
```python
import sys

# print(sys.getrecursionlimit())  # после импорта покажет сколько рекурсий поддержит программа (1000 по умолчанию)
# sys.setrecursionlimit(2000)  # установит новый предел рекурсии
# print(sys.getrecursionlimit())  # после импорта покажет сколько рекурсий поддержит программа (2000)

# найдёт пробелы
def find_probel(x):
    count = 0
    if len(x) == 0:
        return count
    if x[0] == ' ':
        count = 1
    return count + find_probel(x[1:])

print(find_probel('asd asd as wer er'))
```

```python
# факториал
def fact(a):
    if a <= 0:
        return 1
    return a * fact(a - 1)

print(fact(5))
```

```python
# функция преобразует с рекурсией любой сложности список к простому списку
def flatten(base_list, total_list=None):
    if total_list == None:  # точка окончания цикла (рекурсии)
        total_list = []
    for elem in base_list:  # прошли в цикле по всему списку
        if type(elem) == list:  # если элемент список,то
            flatten(elem, total_list)  # то возьмём функцию от элемента
        else:
            total_list.append(elem)  # если элемент не список(число), то добавим его в новый список
    return total_list  # результат наш новый список из чисел

print(flatten([1, [2, 3, [4]], 5]))
print(flatten([[[[9]]], [1, 2], [[8]]]))  # [9, 1, 2, 8]

# или так проще
def flatten(base_list):
    for elem in base_list:  # прошли в цикле по всему списку
        if type(elem) == list:  # если элемент список,то
            flatten(elem)  # то возьмём функцию от элемента
        else:
            total_list.append(elem)  # если элемент не список(число), то добавим его в новый список
    return total_list  # результат наш новый список из чисел

total_list = []
print(flatten([1, [2, 3, [4]], 5]))  # [1, 2, 3, 4, 5]
total_list = []
print(flatten([[[[9]]], [1, 2], [[8]]]))  # [9, 1, 2, 8]
```