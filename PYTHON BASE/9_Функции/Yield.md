```python
# Функция-генератор могут возвращать значение и приостанавливать свою работу,
# а позднее продолжить свою работу с места остановки
# Для создания функции генератора используется ключевое слово yield.
# Генератор - итератор, элементы которого можно итерировать только один раз
# Итератор - объект, который поддерживает функцию next(). Помнит о том, какой элемент будет браться следующим
# Итерируемый объект - объект, который предоставляет возможность обойти поочередно свои элементы.
# Может быть преобразован к итератору.


# пример функции-генератора (она будет выдавать по одному объекту при обращении к ней)
def genf():
    s = 5
    for x in [2, 4, 7]:
        yield x  # выполнит возврат первого значения и заморозится до следующего обращения
        print(s)
        s = s * 10 + 5

w = genf()
print(next(w))  # 2 вывод 1-го значения в списке и остановка
print(next(w))  # 5 4 вывод переменной s(5) и вывод 2-го элемента, запишет в s 55
print(next(w))  # 55 7 вывод переменной s(55)

# или обойдём в цикле все элементы
# for i in genf():
#     print(i)  # 2  4  7
```

```python
# найдём факториал от числа в обычной функции и запишем в список и с помощью функции-генератора
def fact(n):  # обычная функция
    pr = 1
    a = []
    for i in range(1, n + 1):
        pr *= i
        a.append(pr)
    return a

print(fact(10))  # [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
```

```python

def genfact(r):  # функция-генератор
    pr = 1
    for i in range(1, r + 1):
        pr *= i
        yield pr

for j in genfact(10):
    print(j, end=' ')  # 1 2 6 24 120 720 5040 40320 362880 3628800
```

```python
# Давайте вспомним как работает обычная функция

def generator():
         return [1,3,4,5]

# при вызове функции generator() – нам разом вернется список [1,3,4,5], но функция генератор представляет из себя функцию
# которая запоминаем на каком обьекте происходила итерация и возвращает элементы по одному.
# Чтобы написать такую функцию смотрите ниже:

def generator():
         for i in range(1,6):
                   yield i  # yield это ключевое слово для генератора

# давайте сохраним функцию в переменную а:
a = generator()

# Теперь мы можем обращаться к нашей переменной а (которая хранит функцию генератор) через функцию next
print(next(a))  # такой вызов будет возвращать по одному элементу из указанных в функции range(1,6)
# Так как эта функция – генератор. Элементы ее можно обойти только один раз!
# Еще раз о ключевом слове yield – Она в буквально смысле замораживает функцию на том месте где она вызывалась и если
# у вас после нее есть код то он выполнится только при следующем вызове функции:

def sayGenerator():
         a = 'like'
         for i in range(5):
                   yield i
                   print(a)
a = sayGenerator()  # сохраняем функцию в переменную а

print(next(a))  # при первом вызове мы выполним итерацию цикла for и выведется цифра 0
print(next(a))  # это второй вызов и так как в первом вызове мы вывели число с цикла for а после него шло

# ключевое слово yield – оно заморозило фунцию и при втором вызове фунцию продолжит выполнять код уже после выполнения
# первой итерации цикла – тоесть выведется like

# Где такая функция генератор может понадобится?
# Например мы делаем функцию factorial которая находит факториал числа от 2 до n – n укажет пользователь.
# Факториалы мы будем записывать в список и вернем их сразу.

def factorial(x):   # факториал с аргументом х – от 0 до x+1
         pr = 1 # переменная в которой будут считаться факториалы.
            a = []  # список в котором будут храниться факториалы
            for i in range(2, i+1): # почему с двух? Умножать 1 на 1 нет смысла.
                        pr = pr * i # записываем в пр факториал.
                   a.append(pr) # записываем факториал в список
         return a
         # возвращаем все факториалы числа x

# Теперь фунция вернет список в котором хранятся факториалы числа x. Но этот список будет занимать место в памяти. 
# И это можно решить функцией генератором

def factorialGenerator(x):  # функция генератор факториал.
         Pr = 1 # переменная в которую записывается факториал
         for i in range(2, x+1):    # обходим все цифры от 2 до х + 1
                   pr = pr * i  # записываем факториал в pr
                   yield pr # возвращаем факториал i числа.
# Теперь наша функция будет возвращать факториал от 2 до x и она итерабельна, то есть можно к ней вызывать функцию next.
# И самое главное она не занимает места в памяти.
```